__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1657697854207, "socketio.asgi": [".py", "import engineio\n\n\nclass ASGIApp(engineio.ASGIApp):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,socketio_server,other_asgi_app=None ,\n static_files=None ,socketio_path='socket.io',\n on_startup=None ,on_shutdown=None ):\n  super().__init__(socketio_server,other_asgi_app,\n  static_files=static_files,\n  engineio_path=socketio_path,on_startup=on_startup,\n  on_shutdown=on_shutdown)\n", ["engineio"]], "socketio.asyncio_aiopika_manager": [".py", "import asyncio\nimport pickle\n\nfrom socketio.asyncio_pubsub_manager import AsyncPubSubManager\n\ntry :\n import aio_pika\nexcept ImportError:\n aio_pika=None\n \n \nclass AsyncAioPikaManager(AsyncPubSubManager):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n name='asyncaiopika'\n \n def __init__(self,url='amqp://guest:guest@localhost:5672//',\n channel='socketio',write_only=False ,logger=None ):\n  if aio_pika is None :\n   raise RuntimeError('aio_pika package is not installed '\n   '(Run \"pip install aio_pika\" in your '\n   'virtualenv).')\n  self.url=url\n  self.listener_connection=None\n  self.listener_channel=None\n  self.listener_queue=None\n  super().__init__(channel=channel,write_only=write_only,logger=logger)\n  \n async def _connection(self):\n  return await aio_pika.connect_robust(self.url)\n  \n async def _channel(self,connection):\n  return await connection.channel()\n  \n async def _exchange(self,channel):\n  return await channel.declare_exchange(self.channel,\n  aio_pika.ExchangeType.FANOUT)\n  \n async def _queue(self,channel,exchange):\n  queue=await channel.declare_queue(durable=False ,\n  arguments={'x-expires':300000})\n  await queue.bind(exchange)\n  return queue\n  \n async def _publish(self,data):\n  connection=await self._connection()\n  channel=await self._channel(connection)\n  exchange=await self._exchange(channel)\n  await exchange.publish(\n  aio_pika.Message(body=pickle.dumps(data),\n  delivery_mode=aio_pika.DeliveryMode.PERSISTENT),\n  routing_key='*'\n  )\n  \n async def _listen(self):\n  retry_sleep=1\n  while True :\n   try :\n    if self.listener_connection is None :\n     self.listener_connection=await self._connection()\n     self.listener_channel=await self._channel(\n     self.listener_connection\n     )\n     await self.listener_channel.set_qos(prefetch_count=1)\n     exchange=await self._exchange(self.listener_channel)\n     self.listener_queue=await self._queue(\n     self.listener_channel,exchange\n     )\n     retry_sleep=1\n     \n    async with self.listener_queue.iterator()as queue_iter:\n     async for message in queue_iter:\n      async with message.process():\n       yield pickle.loads(message.body)\n   except Exception:\n    self._get_logger().error('Cannot receive from rabbitmq... '\n    'retrying in '\n    '{} secs'.format(retry_sleep))\n    self.listener_connection=None\n    await asyncio.sleep(retry_sleep)\n    retry_sleep *=2\n    if retry_sleep >60:\n     retry_sleep=60\n", ["aio_pika", "asyncio", "pickle", "socketio.asyncio_pubsub_manager"]], "socketio.asyncio_client": [".py", "import asyncio\nimport logging\nimport random\n\nimport engineio\n\nfrom . import client\nfrom . import exceptions\nfrom . import packet\n\ndefault_logger=logging.getLogger('socketio.client')\n\n\nclass AsyncClient(client.Client):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def is_asyncio_based(self):\n  return True\n  \n async def connect(self,url,headers={},auth=None ,transports=None ,\n namespaces=None ,socketio_path='socket.io',wait=True ,\n wait_timeout=1):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self.connected:\n   raise exceptions.ConnectionError('Already connected')\n   \n  self.connection_url=url\n  self.connection_headers=headers\n  self.connection_auth=auth\n  self.connection_transports=transports\n  self.connection_namespaces=namespaces\n  self.socketio_path=socketio_path\n  \n  if namespaces is None :\n   namespaces=list(set(self.handlers.keys()).union(\n   set(self.namespace_handlers.keys())))\n   if len(namespaces)==0:\n    namespaces=['/']\n  elif isinstance(namespaces,str):\n   namespaces=[namespaces]\n  self.connection_namespaces=namespaces\n  self.namespaces={}\n  if self._connect_event is None :\n   self._connect_event=self.eio.create_event()\n  else :\n   self._connect_event.clear()\n  real_url=await self._get_real_value(self.connection_url)\n  real_headers=await self._get_real_value(self.connection_headers)\n  try :\n   await self.eio.connect(real_url,headers=real_headers,\n   transports=transports,\n   engineio_path=socketio_path)\n  except engineio.exceptions.ConnectionError as exc:\n   await self._trigger_event(\n   'connect_error','/',\n   exc.args[1]if len(exc.args)>1 else exc.args[0])\n   raise exceptions.ConnectionError(exc.args[0])from None\n   \n  if wait:\n   try :\n    while True :\n     await asyncio.wait_for(self._connect_event.wait(),\n     wait_timeout)\n     self._connect_event.clear()\n     if set(self.namespaces)==set(self.connection_namespaces):\n      break\n   except asyncio.TimeoutError:\n    pass\n   if set(self.namespaces)!=set(self.connection_namespaces):\n    await self.disconnect()\n    raise exceptions.ConnectionError(\n    'One or more namespaces failed to connect')\n    \n  self.connected=True\n  \n async def wait(self):\n  ''\n\n\n\n\n\n  \n  while True :\n   await self.eio.wait()\n   await self.sleep(1)\n   if not self._reconnect_task:\n    break\n   await self._reconnect_task\n   if self.eio.state !='connected':\n    break\n    \n async def emit(self,event,data=None ,namespace=None ,callback=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  if namespace not in self.namespaces:\n   raise exceptions.BadNamespaceError(\n   namespace+' is not a connected namespace.')\n  self.logger.info('Emitting event \"%s\" [%s]',event,namespace)\n  if callback is not None :\n   id=self._generate_ack_id(namespace,callback)\n  else :\n   id=None\n   \n   \n  if isinstance(data,tuple):\n   data=list(data)\n  elif data is not None :\n   data=[data]\n  else :\n   data=[]\n  await self._send_packet(self.packet_class(\n  packet.EVENT,namespace=namespace,data=[event]+data,id=id))\n  \n async def send(self,data,namespace=None ,callback=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  await self.emit('message',data=data,namespace=namespace,\n  callback=callback)\n  \n async def call(self,event,data=None ,namespace=None ,timeout=60):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  callback_event=self.eio.create_event()\n  callback_args=[]\n  \n  def event_callback(*args):\n   callback_args.append(args)\n   callback_event.set()\n   \n  await self.emit(event,data=data,namespace=namespace,\n  callback=event_callback)\n  try :\n   await asyncio.wait_for(callback_event.wait(),timeout)\n  except asyncio.TimeoutError:\n   raise exceptions.TimeoutError()from None\n  return callback_args[0]if len(callback_args[0])>1\\\n  else callback_args[0][0]if len(callback_args[0])==1\\\n  else None\n  \n async def disconnect(self):\n  ''\n\n\n  \n  \n  \n  for n in self.namespaces:\n   await self._send_packet(self.packet_class(packet.DISCONNECT,\n   namespace=n))\n  await self.eio.disconnect(abort=True )\n  \n def start_background_task(self,target,*args,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  return self.eio.start_background_task(target,*args,**kwargs)\n  \n async def sleep(self,seconds=0):\n  ''\n\n\n\n\n\n\n\n  \n  return await self.eio.sleep(seconds)\n  \n async def _get_real_value(self,value):\n  ''\n  \n  if not callable(value):\n   return value\n  if asyncio.iscoroutinefunction(value):\n   return await value()\n  return value()\n  \n async def _send_packet(self,pkt):\n  ''\n  encoded_packet=pkt.encode()\n  if isinstance(encoded_packet,list):\n   for ep in encoded_packet:\n    await self.eio.send(ep)\n  else :\n   await self.eio.send(encoded_packet)\n   \n async def _handle_connect(self,namespace,data):\n  namespace=namespace or '/'\n  if namespace not in self.namespaces:\n   self.logger.info('Namespace {} is connected'.format(namespace))\n   self.namespaces[namespace]=(data or {}).get('sid',self.sid)\n   await self._trigger_event('connect',namespace=namespace)\n   self._connect_event.set()\n   \n async def _handle_disconnect(self,namespace):\n  if not self.connected:\n   return\n  namespace=namespace or '/'\n  await self._trigger_event('disconnect',namespace=namespace)\n  if namespace in self.namespaces:\n   del self.namespaces[namespace]\n  if not self.namespaces:\n   self.connected=False\n   await self.eio.disconnect(abort=True )\n   \n async def _handle_event(self,namespace,id,data):\n  namespace=namespace or '/'\n  self.logger.info('Received event \"%s\" [%s]',data[0],namespace)\n  r=await self._trigger_event(data[0],namespace,*data[1:])\n  if id is not None :\n  \n  \n   if r is None :\n    data=[]\n   elif isinstance(r,tuple):\n    data=list(r)\n   else :\n    data=[r]\n   await self._send_packet(self.packet_class(\n   packet.ACK,namespace=namespace,id=id,data=data))\n   \n async def _handle_ack(self,namespace,id,data):\n  namespace=namespace or '/'\n  self.logger.info('Received ack [%s]',namespace)\n  callback=None\n  try :\n   callback=self.callbacks[namespace][id]\n  except KeyError:\n  \n   self.logger.warning('Unknown callback received, ignoring.')\n  else :\n   del self.callbacks[namespace][id]\n  if callback is not None :\n   if asyncio.iscoroutinefunction(callback):\n    await callback(*data)\n   else :\n    callback(*data)\n    \n async def _handle_error(self,namespace,data):\n  namespace=namespace or '/'\n  self.logger.info('Connection to namespace {} was rejected'.format(\n  namespace))\n  if data is None :\n   data=tuple()\n  elif not isinstance(data,(tuple,list)):\n   data=(data,)\n  await self._trigger_event('connect_error',namespace,*data)\n  self._connect_event.set()\n  if namespace in self.namespaces:\n   del self.namespaces[namespace]\n  if namespace =='/':\n   self.namespaces={}\n   self.connected=False\n   \n async def _trigger_event(self,event,namespace,*args):\n  ''\n  \n  if namespace in self.handlers:\n   handler=None\n   if event in self.handlers[namespace]:\n    handler=self.handlers[namespace][event]\n   elif event not in self.reserved_events and\\\n   '*'in self.handlers[namespace]:\n    handler=self.handlers[namespace]['*']\n    args=(event,*args)\n   if handler:\n    if asyncio.iscoroutinefunction(handler):\n     try :\n      ret=await handler(*args)\n     except asyncio.CancelledError:\n      ret=None\n    else :\n     ret=handler(*args)\n    return ret\n    \n    \n  elif namespace in self.namespace_handlers:\n   return await self.namespace_handlers[namespace].trigger_event(\n   event,*args)\n   \n async def _handle_reconnect(self):\n  if self._reconnect_abort is None :\n   self._reconnect_abort=self.eio.create_event()\n  self._reconnect_abort.clear()\n  client.reconnecting_clients.append(self)\n  attempt_count=0\n  current_delay=self.reconnection_delay\n  while True :\n   delay=current_delay\n   current_delay *=2\n   if delay >self.reconnection_delay_max:\n    delay=self.reconnection_delay_max\n   delay +=self.randomization_factor *(2 *random.random()-1)\n   self.logger.info(\n   'Connection failed, new attempt in {:.02f} seconds'.format(\n   delay))\n   try :\n    await asyncio.wait_for(self._reconnect_abort.wait(),delay)\n    self.logger.info('Reconnect task aborted')\n    break\n   except (asyncio.TimeoutError,asyncio.CancelledError):\n    pass\n   attempt_count +=1\n   try :\n    await self.connect(self.connection_url,\n    headers=self.connection_headers,\n    auth=self.connection_auth,\n    transports=self.connection_transports,\n    namespaces=self.connection_namespaces,\n    socketio_path=self.socketio_path)\n   except (exceptions.ConnectionError,ValueError):\n    pass\n   else :\n    self.logger.info('Reconnection successful')\n    self._reconnect_task=None\n    break\n   if self.reconnection_attempts and\\\n   attempt_count >=self.reconnection_attempts:\n    self.logger.info(\n    'Maximum reconnection attempts reached, giving up')\n    break\n  client.reconnecting_clients.remove(self)\n  \n async def _handle_eio_connect(self):\n  ''\n  self.logger.info('Engine.IO connection established')\n  self.sid=self.eio.sid\n  real_auth=await self._get_real_value(self.connection_auth)or {}\n  for n in self.connection_namespaces:\n   await self._send_packet(self.packet_class(\n   packet.CONNECT,data=real_auth,namespace=n))\n   \n async def _handle_eio_message(self,data):\n  ''\n  if self._binary_packet:\n   pkt=self._binary_packet\n   if pkt.add_attachment(data):\n    self._binary_packet=None\n    if pkt.packet_type ==packet.BINARY_EVENT:\n     await self._handle_event(pkt.namespace,pkt.id,pkt.data)\n    else :\n     await self._handle_ack(pkt.namespace,pkt.id,pkt.data)\n  else :\n   pkt=self.packet_class(encoded_packet=data)\n   if pkt.packet_type ==packet.CONNECT:\n    await self._handle_connect(pkt.namespace,pkt.data)\n   elif pkt.packet_type ==packet.DISCONNECT:\n    await self._handle_disconnect(pkt.namespace)\n   elif pkt.packet_type ==packet.EVENT:\n    await self._handle_event(pkt.namespace,pkt.id,pkt.data)\n   elif pkt.packet_type ==packet.ACK:\n    await self._handle_ack(pkt.namespace,pkt.id,pkt.data)\n   elif pkt.packet_type ==packet.BINARY_EVENT or\\\n   pkt.packet_type ==packet.BINARY_ACK:\n    self._binary_packet=pkt\n   elif pkt.packet_type ==packet.CONNECT_ERROR:\n    await self._handle_error(pkt.namespace,pkt.data)\n   else :\n    raise ValueError('Unknown packet type.')\n    \n async def _handle_eio_disconnect(self):\n  ''\n  self.logger.info('Engine.IO connection dropped')\n  if self.connected:\n   for n in self.namespaces:\n    await self._trigger_event('disconnect',namespace=n)\n   self.namespaces={}\n   self.connected=False\n  self.callbacks={}\n  self._binary_packet=None\n  self.sid=None\n  if self.eio.state =='connected'and self.reconnection:\n   self._reconnect_task=self.start_background_task(\n   self._handle_reconnect)\n   \n def _engineio_client_class(self):\n  return engineio.AsyncClient\n", ["asyncio", "engineio", "logging", "random", "socketio"]], "socketio.asyncio_manager": [".py", "import asyncio\n\nfrom .base_manager import BaseManager\n\n\nclass AsyncManager(BaseManager):\n ''\n async def can_disconnect(self,sid,namespace):\n  return self.is_connected(sid,namespace)\n  \n async def emit(self,event,data,namespace,room=None ,skip_sid=None ,\n callback=None ,**kwargs):\n  ''\n\n\n\n  \n  if namespace not in self.rooms or room not in self.rooms[namespace]:\n   return\n  tasks=[]\n  if not isinstance(skip_sid,list):\n   skip_sid=[skip_sid]\n  for sid,eio_sid in self.get_participants(namespace,room):\n   if sid not in skip_sid:\n    if callback is not None :\n     id=self._generate_ack_id(sid,callback)\n    else :\n     id=None\n    tasks.append(asyncio.create_task(\n    self.server._emit_internal(eio_sid,event,data,\n    namespace,id)))\n  if tasks ==[]:\n   return\n  await asyncio.wait(tasks)\n  \n async def close_room(self,room,namespace):\n  ''\n\n\n  \n  return super().close_room(room,namespace)\n  \n async def trigger_callback(self,sid,id,data):\n  ''\n\n\n  \n  callback=None\n  try :\n   callback=self.callbacks[sid][id]\n  except KeyError:\n  \n   self._get_logger().warning('Unknown callback received, ignoring.')\n  else :\n   del self.callbacks[sid][id]\n  if callback is not None :\n   ret=callback(*data)\n   if asyncio.iscoroutine(ret):\n    try :\n     await ret\n    except asyncio.CancelledError:\n     pass\n", ["asyncio", "socketio.base_manager"]], "socketio.asyncio_namespace": [".py", "import asyncio\n\nfrom socketio import namespace\n\n\nclass AsyncNamespace(namespace.Namespace):\n ''\n\n\n\n\n\n\n\n\n\n\n \n def is_asyncio_based(self):\n  return True\n  \n async def trigger_event(self,event,*args):\n  ''\n\n\n\n\n\n\n\n  \n  handler_name='on_'+event\n  if hasattr(self,handler_name):\n   handler=getattr(self,handler_name)\n   if asyncio.iscoroutinefunction(handler)is True :\n    try :\n     ret=await handler(*args)\n    except asyncio.CancelledError:\n     ret=None\n   else :\n    ret=handler(*args)\n   return ret\n   \n async def emit(self,event,data=None ,to=None ,room=None ,skip_sid=None ,\n namespace=None ,callback=None ):\n  ''\n\n\n\n\n\n\n  \n  return await self.server.emit(event,data=data,to=to,room=room,\n  skip_sid=skip_sid,\n  namespace=namespace or self.namespace,\n  callback=callback)\n  \n async def send(self,data,to=None ,room=None ,skip_sid=None ,\n namespace=None ,callback=None ):\n  ''\n\n\n\n\n\n\n  \n  return await self.server.send(data,to=to,room=room,\n  skip_sid=skip_sid,\n  namespace=namespace or self.namespace,\n  callback=callback)\n  \n async def call(self,event,data=None ,to=None ,sid=None ,namespace=None ,\n timeout=None ):\n  ''\n\n\n\n\n  \n  return await self.server.call(event,data=data,to=to,sid=sid,\n  namespace=namespace or self.namespace,\n  timeout=timeout)\n  \n async def close_room(self,room,namespace=None ):\n  ''\n\n\n\n\n\n\n  \n  return await self.server.close_room(\n  room,namespace=namespace or self.namespace)\n  \n async def get_session(self,sid,namespace=None ):\n  ''\n\n\n\n\n\n\n  \n  return await self.server.get_session(\n  sid,namespace=namespace or self.namespace)\n  \n async def save_session(self,sid,session,namespace=None ):\n  ''\n\n\n\n\n\n\n  \n  return await self.server.save_session(\n  sid,session,namespace=namespace or self.namespace)\n  \n def session(self,sid,namespace=None ):\n  ''\n\n\n\n\n  \n  return self.server.session(sid,namespace=namespace or self.namespace)\n  \n async def disconnect(self,sid,namespace=None ):\n  ''\n\n\n\n\n\n\n  \n  return await self.server.disconnect(\n  sid,namespace=namespace or self.namespace)\n  \n  \nclass AsyncClientNamespace(namespace.ClientNamespace):\n ''\n\n\n\n\n\n\n\n\n\n\n \n def is_asyncio_based(self):\n  return True\n  \n async def trigger_event(self,event,*args):\n  ''\n\n\n\n\n\n\n\n  \n  handler_name='on_'+event\n  if hasattr(self,handler_name):\n   handler=getattr(self,handler_name)\n   if asyncio.iscoroutinefunction(handler)is True :\n    try :\n     ret=await handler(*args)\n    except asyncio.CancelledError:\n     ret=None\n   else :\n    ret=handler(*args)\n   return ret\n   \n async def emit(self,event,data=None ,namespace=None ,callback=None ):\n  ''\n\n\n\n\n\n\n  \n  return await self.client.emit(event,data=data,\n  namespace=namespace or self.namespace,\n  callback=callback)\n  \n async def send(self,data,namespace=None ,callback=None ):\n  ''\n\n\n\n\n\n\n  \n  return await self.client.send(data,\n  namespace=namespace or self.namespace,\n  callback=callback)\n  \n async def call(self,event,data=None ,namespace=None ,timeout=None ):\n  ''\n\n\n\n\n  \n  return await self.client.call(event,data=data,\n  namespace=namespace or self.namespace,\n  timeout=timeout)\n  \n async def disconnect(self):\n  ''\n\n\n\n\n\n\n  \n  return await self.client.disconnect()\n", ["asyncio", "socketio"]], "socketio.asyncio_pubsub_manager": [".py", "import asyncio\nfrom functools import partial\nimport uuid\n\nfrom engineio import json\nimport pickle\n\nfrom .asyncio_manager import AsyncManager\n\n\nclass AsyncPubSubManager(AsyncManager):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n name='asyncpubsub'\n \n def __init__(self,channel='socketio',write_only=False ,logger=None ):\n  super().__init__()\n  self.channel=channel\n  self.write_only=write_only\n  self.host_id=uuid.uuid4().hex\n  self.logger=logger\n  \n def initialize(self):\n  super().initialize()\n  if not self.write_only:\n   self.thread=self.server.start_background_task(self._thread)\n  self._get_logger().info(self.name+' backend initialized.')\n  \n async def emit(self,event,data,namespace=None ,room=None ,skip_sid=None ,\n callback=None ,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n  \n  if kwargs.get('ignore_queue'):\n   return await super().emit(\n   event,data,namespace=namespace,room=room,skip_sid=skip_sid,\n   callback=callback)\n  namespace=namespace or '/'\n  if callback is not None :\n   if self.server is None :\n    raise RuntimeError('Callbacks can only be issued from the '\n    'context of a server.')\n   if room is None :\n    raise ValueError('Cannot use callback without a room set.')\n   id=self._generate_ack_id(room,callback)\n   callback=(room,namespace,id)\n  else :\n   callback=None\n  await self._publish({'method':'emit','event':event,'data':data,\n  'namespace':namespace,'room':room,\n  'skip_sid':skip_sid,'callback':callback,\n  'host_id':self.host_id})\n  \n async def can_disconnect(self,sid,namespace):\n  if self.is_connected(sid,namespace):\n  \n   return await super().can_disconnect(sid,namespace)\n  else :\n  \n   await self._publish({'method':'disconnect','sid':sid,\n   'namespace':namespace or '/'})\n   \n async def close_room(self,room,namespace=None ):\n  await self._publish({'method':'close_room','room':room,\n  'namespace':namespace or '/'})\n  \n async def _publish(self,data):\n  ''\n\n\n\n  \n  raise NotImplementedError('This method must be implemented in a '\n  'subclass.')\n  \n async def _listen(self):\n  ''\n\n\n\n\n  \n  raise NotImplementedError('This method must be implemented in a '\n  'subclass.')\n  \n async def _handle_emit(self,message):\n \n \n \n  remote_callback=message.get('callback')\n  remote_host_id=message.get('host_id')\n  if remote_callback is not None and len(remote_callback)==3:\n   callback=partial(self._return_callback,remote_host_id,\n   *remote_callback)\n  else :\n   callback=None\n  await super().emit(message['event'],message['data'],\n  namespace=message.get('namespace'),\n  room=message.get('room'),\n  skip_sid=message.get('skip_sid'),\n  callback=callback)\n  \n async def _handle_callback(self,message):\n  if self.host_id ==message.get('host_id'):\n   try :\n    sid=message['sid']\n    id=message['id']\n    args=message['args']\n   except KeyError:\n    return\n   await self.trigger_callback(sid,id,args)\n   \n async def _return_callback(self,host_id,sid,namespace,callback_id,\n *args):\n \n \n  await self._publish({'method':'callback','host_id':host_id,\n  'sid':sid,'namespace':namespace,\n  'id':callback_id,'args':args})\n  \n async def _handle_disconnect(self,message):\n  await self.server.disconnect(sid=message.get('sid'),\n  namespace=message.get('namespace'),\n  ignore_queue=True )\n  \n async def _handle_close_room(self,message):\n  await super().close_room(\n  room=message.get('room'),namespace=message.get('namespace'))\n  \n async def _thread(self):\n  while True :\n   try :\n    async for message in self._listen():\n     data=None\n     if isinstance(message,dict):\n      data=message\n     else :\n      if isinstance(message,bytes):\n       try :\n        data=pickle.loads(message)\n       except :\n        pass\n      if data is None :\n       try :\n        data=json.loads(message)\n       except :\n        pass\n     if data and 'method'in data:\n      self._get_logger().info('pubsub message: {}'.format(\n      data['method']))\n      try :\n       if data['method']=='emit':\n        await self._handle_emit(data)\n       elif data['method']=='callback':\n        await self._handle_callback(data)\n       elif data['method']=='disconnect':\n        await self._handle_disconnect(data)\n       elif data['method']=='close_room':\n        await self._handle_close_room(data)\n      except asyncio.CancelledError:\n       raise\n      except :\n       self.server.logger.exception(\n       'Unknown error in pubsub listening task')\n   except asyncio.CancelledError:\n    break\n   except :\n    import traceback\n    traceback.print_exc()\n", ["asyncio", "engineio", "functools", "pickle", "socketio.asyncio_manager", "traceback", "uuid"]], "socketio.asyncio_redis_manager": [".py", "import asyncio\nimport pickle\n\ntry :\n from redis import asyncio as aioredis\n from redis.exceptions import RedisError\nexcept ImportError:\n try :\n  import aioredis\n  from aioredis.exceptions import RedisError\n except ImportError:\n  aioredis=None\n  RedisError=None\n  \nfrom .asyncio_pubsub_manager import AsyncPubSubManager\n\n\nclass AsyncRedisManager(AsyncPubSubManager):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name='aioredis'\n \n def __init__(self,url='redis://localhost:6379/0',channel='socketio',\n write_only=False ,logger=None ,redis_options=None ):\n  if aioredis is None :\n   raise RuntimeError('Redis package is not installed '\n   '(Run \"pip install redis\" in your virtualenv).')\n  if not hasattr(aioredis.Redis,'from_url'):\n   raise RuntimeError('Version 2 of aioredis package is required.')\n  self.redis_url=url\n  self.redis_options=redis_options or {}\n  self._redis_connect()\n  super().__init__(channel=channel,write_only=write_only,logger=logger)\n  \n def _redis_connect(self):\n  self.redis=aioredis.Redis.from_url(self.redis_url,\n  **self.redis_options)\n  self.pubsub=self.redis.pubsub(ignore_subscribe_messages=True )\n  \n async def _publish(self,data):\n  retry=True\n  while True :\n   try :\n    if not retry:\n     self._redis_connect()\n    return await self.redis.publish(\n    self.channel,pickle.dumps(data))\n   except RedisError:\n    if retry:\n     self._get_logger().error('Cannot publish to redis... '\n     'retrying')\n     retry=False\n    else :\n     self._get_logger().error('Cannot publish to redis... '\n     'giving up')\n     break\n     \n async def _redis_listen_with_retries(self):\n  retry_sleep=1\n  connect=False\n  while True :\n   try :\n    if connect:\n     self._redis_connect()\n     await self.pubsub.subscribe(self.channel)\n     retry_sleep=1\n    async for message in self.pubsub.listen():\n     yield message\n   except RedisError:\n    self._get_logger().error('Cannot receive from redis... '\n    'retrying in '\n    '{} secs'.format(retry_sleep))\n    connect=True\n    await asyncio.sleep(retry_sleep)\n    retry_sleep *=2\n    if retry_sleep >60:\n     retry_sleep=60\n     \n async def _listen(self):\n  channel=self.channel.encode('utf-8')\n  await self.pubsub.subscribe(self.channel)\n  async for message in self._redis_listen_with_retries():\n   if message['channel']==channel and\\\n   message['type']=='message'and 'data'in message:\n    yield message['data']\n  await self.pubsub.unsubscribe(self.channel)\n", ["aioredis", "aioredis.exceptions", "asyncio", "pickle", "redis", "redis.exceptions", "socketio.asyncio_pubsub_manager"]], "socketio.asyncio_server": [".py", "import asyncio\n\nimport engineio\n\nfrom . import asyncio_manager\nfrom . import exceptions\nfrom . import packet\nfrom . import server\n\n\nclass AsyncServer(server.Server):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,client_manager=None ,logger=False ,json=None ,\n async_handlers=True ,**kwargs):\n  if client_manager is None :\n   client_manager=asyncio_manager.AsyncManager()\n  super().__init__(client_manager=client_manager,logger=logger,\n  json=json,async_handlers=async_handlers,**kwargs)\n  \n def is_asyncio_based(self):\n  return True\n  \n def attach(self,app,socketio_path='socket.io'):\n  ''\n  self.eio.attach(app,socketio_path)\n  \n async def emit(self,event,data=None ,to=None ,room=None ,skip_sid=None ,\n namespace=None ,callback=None ,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  room=to or room\n  self.logger.info('emitting event \"%s\" to %s [%s]',event,\n  room or 'all',namespace)\n  await self.manager.emit(event,data,namespace,room=room,\n  skip_sid=skip_sid,callback=callback,\n  **kwargs)\n  \n async def send(self,data,to=None ,room=None ,skip_sid=None ,\n namespace=None ,callback=None ,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  await self.emit('message',data=data,to=to,room=room,\n  skip_sid=skip_sid,namespace=namespace,\n  callback=callback,**kwargs)\n  \n async def call(self,event,data=None ,to=None ,sid=None ,namespace=None ,\n timeout=60,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if to is None and sid is None :\n   raise ValueError('Cannot use call() to broadcast.')\n  if not self.async_handlers:\n   raise RuntimeError(\n   'Cannot use call() when async_handlers is False.')\n  callback_event=self.eio.create_event()\n  callback_args=[]\n  \n  def event_callback(*args):\n   callback_args.append(args)\n   callback_event.set()\n   \n  await self.emit(event,data=data,room=to or sid,namespace=namespace,\n  callback=event_callback,**kwargs)\n  try :\n   await asyncio.wait_for(callback_event.wait(),timeout)\n  except asyncio.TimeoutError:\n   raise exceptions.TimeoutError()from None\n  return callback_args[0]if len(callback_args[0])>1\\\n  else callback_args[0][0]if len(callback_args[0])==1\\\n  else None\n  \n async def close_room(self,room,namespace=None ):\n  ''\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  self.logger.info('room %s is closing [%s]',room,namespace)\n  await self.manager.close_room(room,namespace)\n  \n async def get_session(self,sid,namespace=None ):\n  ''\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  eio_sid=self.manager.eio_sid_from_sid(sid,namespace)\n  eio_session=await self.eio.get_session(eio_sid)\n  return eio_session.setdefault(namespace,{})\n  \n async def save_session(self,sid,session,namespace=None ):\n  ''\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  eio_sid=self.manager.eio_sid_from_sid(sid,namespace)\n  eio_session=await self.eio.get_session(eio_sid)\n  eio_session[namespace]=session\n  \n def session(self,sid,namespace=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  class _session_context_manager(object):\n   def __init__(self,server,sid,namespace):\n    self.server=server\n    self.sid=sid\n    self.namespace=namespace\n    self.session=None\n    \n   async def __aenter__(self):\n    self.session=await self.server.get_session(\n    sid,namespace=self.namespace)\n    return self.session\n    \n   async def __aexit__(self,*args):\n    await self.server.save_session(sid,self.session,\n    namespace=self.namespace)\n    \n  return _session_context_manager(self,sid,namespace)\n  \n async def disconnect(self,sid,namespace=None ,ignore_queue=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  if ignore_queue:\n   delete_it=self.manager.is_connected(sid,namespace)\n  else :\n   delete_it=await self.manager.can_disconnect(sid,namespace)\n  if delete_it:\n   self.logger.info('Disconnecting %s [%s]',sid,namespace)\n   eio_sid=self.manager.pre_disconnect(sid,namespace=namespace)\n   await self._send_packet(eio_sid,self.packet_class(\n   packet.DISCONNECT,namespace=namespace))\n   await self._trigger_event('disconnect',namespace,sid)\n   self.manager.disconnect(sid,namespace=namespace)\n   \n async def handle_request(self,*args,**kwargs):\n  ''\n\n\n\n\n\n  \n  return await self.eio.handle_request(*args,**kwargs)\n  \n def start_background_task(self,target,*args,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  return self.eio.start_background_task(target,*args,**kwargs)\n  \n async def sleep(self,seconds=0):\n  ''\n\n\n\n\n\n\n\n  \n  return await self.eio.sleep(seconds)\n  \n async def _emit_internal(self,sid,event,data,namespace=None ,id=None ):\n  ''\n  \n  \n  if isinstance(data,tuple):\n   data=list(data)\n  elif data is not None :\n   data=[data]\n  else :\n   data=[]\n  await self._send_packet(sid,self.packet_class(\n  packet.EVENT,namespace=namespace,data=[event]+data,id=id))\n  \n async def _send_packet(self,eio_sid,pkt):\n  ''\n  encoded_packet=pkt.encode()\n  if isinstance(encoded_packet,list):\n   for ep in encoded_packet:\n    await self.eio.send(eio_sid,ep)\n  else :\n   await self.eio.send(eio_sid,encoded_packet)\n   \n async def _handle_connect(self,eio_sid,namespace,data):\n  ''\n  namespace=namespace or '/'\n  sid=None\n  if namespace in self.handlers or namespace in self.namespace_handlers:\n   sid=self.manager.connect(eio_sid,namespace)\n  if sid is None :\n   self._send_packet(eio_sid,self.packet_class(\n   packet.CONNECT_ERROR,data='Unable to connect',\n   namespace=namespace))\n   return\n   \n  if self.always_connect:\n   await self._send_packet(eio_sid,self.packet_class(\n   packet.CONNECT,{'sid':sid},namespace=namespace))\n  fail_reason=exceptions.ConnectionRefusedError().error_args\n  try :\n   if data:\n    success=await self._trigger_event(\n    'connect',namespace,sid,self.environ[eio_sid],data)\n   else :\n    try :\n     success=await self._trigger_event(\n     'connect',namespace,sid,self.environ[eio_sid])\n    except TypeError:\n     success=await self._trigger_event(\n     'connect',namespace,sid,self.environ[eio_sid],None )\n  except exceptions.ConnectionRefusedError as exc:\n   fail_reason=exc.error_args\n   success=False\n   \n  if success is False :\n   if self.always_connect:\n    self.manager.pre_disconnect(sid,namespace)\n    await self._send_packet(eio_sid,self.packet_class(\n    packet.DISCONNECT,data=fail_reason,namespace=namespace))\n   else :\n    await self._send_packet(eio_sid,self.packet_class(\n    packet.CONNECT_ERROR,data=fail_reason,\n    namespace=namespace))\n   self.manager.disconnect(sid,namespace)\n  elif not self.always_connect:\n   await self._send_packet(eio_sid,self.packet_class(\n   packet.CONNECT,{'sid':sid},namespace=namespace))\n   \n async def _handle_disconnect(self,eio_sid,namespace):\n  ''\n  namespace=namespace or '/'\n  sid=self.manager.sid_from_eio_sid(eio_sid,namespace)\n  if not self.manager.is_connected(sid,namespace):\n   return\n  self.manager.pre_disconnect(sid,namespace=namespace)\n  await self._trigger_event('disconnect',namespace,sid)\n  self.manager.disconnect(sid,namespace)\n  \n async def _handle_event(self,eio_sid,namespace,id,data):\n  ''\n  namespace=namespace or '/'\n  sid=self.manager.sid_from_eio_sid(eio_sid,namespace)\n  self.logger.info('received event \"%s\" from %s [%s]',data[0],sid,\n  namespace)\n  if not self.manager.is_connected(sid,namespace):\n   self.logger.warning('%s is not connected to namespace %s',\n   sid,namespace)\n   return\n  if self.async_handlers:\n   self.start_background_task(self._handle_event_internal,self,sid,\n   eio_sid,data,namespace,id)\n  else :\n   await self._handle_event_internal(self,sid,eio_sid,data,\n   namespace,id)\n   \n async def _handle_event_internal(self,server,sid,eio_sid,data,\n namespace,id):\n  r=await server._trigger_event(data[0],namespace,sid,*data[1:])\n  if r !=self.not_handled and id is not None :\n  \n  \n   if r is None :\n    data=[]\n   elif isinstance(r,tuple):\n    data=list(r)\n   else :\n    data=[r]\n   await server._send_packet(eio_sid,self.packet_class(\n   packet.ACK,namespace=namespace,id=id,data=data))\n   \n async def _handle_ack(self,eio_sid,namespace,id,data):\n  ''\n  namespace=namespace or '/'\n  sid=self.manager.sid_from_eio_sid(eio_sid,namespace)\n  self.logger.info('received ack from %s [%s]',sid,namespace)\n  await self.manager.trigger_callback(sid,id,data)\n  \n async def _trigger_event(self,event,namespace,*args):\n  ''\n  \n  if namespace in self.handlers:\n   handler=None\n   if event in self.handlers[namespace]:\n    handler=self.handlers[namespace][event]\n   elif event not in self.reserved_events and\\\n   '*'in self.handlers[namespace]:\n    handler=self.handlers[namespace]['*']\n    args=(event,*args)\n   if handler:\n    if asyncio.iscoroutinefunction(handler):\n     try :\n      ret=await handler(*args)\n     except asyncio.CancelledError:\n      ret=None\n    else :\n     ret=handler(*args)\n    return ret\n   else :\n    return self.not_handled\n    \n    \n  elif namespace in self.namespace_handlers:\n   return await self.namespace_handlers[namespace].trigger_event(\n   event,*args)\n   \n async def _handle_eio_connect(self,eio_sid,environ):\n  ''\n  if not self.manager_initialized:\n   self.manager_initialized=True\n   self.manager.initialize()\n  self.environ[eio_sid]=environ\n  \n async def _handle_eio_message(self,eio_sid,data):\n  ''\n  if eio_sid in self._binary_packet:\n   pkt=self._binary_packet[eio_sid]\n   if pkt.add_attachment(data):\n    del self._binary_packet[eio_sid]\n    if pkt.packet_type ==packet.BINARY_EVENT:\n     await self._handle_event(eio_sid,pkt.namespace,pkt.id,\n     pkt.data)\n    else :\n     await self._handle_ack(eio_sid,pkt.namespace,pkt.id,\n     pkt.data)\n  else :\n   pkt=self.packet_class(encoded_packet=data)\n   if pkt.packet_type ==packet.CONNECT:\n    await self._handle_connect(eio_sid,pkt.namespace,pkt.data)\n   elif pkt.packet_type ==packet.DISCONNECT:\n    await self._handle_disconnect(eio_sid,pkt.namespace)\n   elif pkt.packet_type ==packet.EVENT:\n    await self._handle_event(eio_sid,pkt.namespace,pkt.id,\n    pkt.data)\n   elif pkt.packet_type ==packet.ACK:\n    await self._handle_ack(eio_sid,pkt.namespace,pkt.id,\n    pkt.data)\n   elif pkt.packet_type ==packet.BINARY_EVENT or\\\n   pkt.packet_type ==packet.BINARY_ACK:\n    self._binary_packet[eio_sid]=pkt\n   elif pkt.packet_type ==packet.CONNECT_ERROR:\n    raise ValueError('Unexpected CONNECT_ERROR packet.')\n   else :\n    raise ValueError('Unknown packet type.')\n    \n async def _handle_eio_disconnect(self,eio_sid):\n  ''\n  for n in list(self.manager.get_namespaces()).copy():\n   await self._handle_disconnect(eio_sid,n)\n  if eio_sid in self.environ:\n   del self.environ[eio_sid]\n   \n def _engineio_server_class(self):\n  return engineio.AsyncServer\n", ["asyncio", "engineio", "socketio"]], "socketio.base_manager": [".py", "import itertools\nimport logging\n\nfrom bidict import bidict,ValueDuplicationError\n\ndefault_logger=logging.getLogger('socketio')\n\n\nclass BaseManager(object):\n ''\n\n\n\n\n\n\n \n def __init__(self):\n  self.logger=None\n  self.server=None\n  self.rooms={}\n  self.eio_to_sid={}\n  self.callbacks={}\n  self.pending_disconnect={}\n  \n def set_server(self,server):\n  self.server=server\n  \n def initialize(self):\n  ''\n\n  \n  pass\n  \n def get_namespaces(self):\n  ''\n  return self.rooms.keys()\n  \n def get_participants(self,namespace,room):\n  ''\n  ns=self.rooms[namespace]\n  if hasattr(room,'__len__')and not isinstance(room,str):\n   participants=ns[room[0]]._fwdm.copy()if room[0]in ns else {}\n   for r in room[1:]:\n    participants.update(ns[r]._fwdm if r in ns else {})\n  else :\n   participants=ns[room]._fwdm.copy()if room in ns else {}\n  for sid,eio_sid in participants.items():\n   yield sid,eio_sid\n   \n def connect(self,eio_sid,namespace):\n  ''\n  sid=self.server.eio.generate_id()\n  try :\n   self.enter_room(sid,namespace,None ,eio_sid=eio_sid)\n  except ValueDuplicationError:\n  \n   return None\n  self.enter_room(sid,namespace,sid,eio_sid=eio_sid)\n  return sid\n  \n def is_connected(self,sid,namespace):\n  if namespace in self.pending_disconnect and\\\n  sid in self.pending_disconnect[namespace]:\n  \n   return False\n  try :\n   return self.rooms[namespace][None ][sid]is not None\n  except KeyError:\n   pass\n   \n def sid_from_eio_sid(self,eio_sid,namespace):\n  try :\n   return self.rooms[namespace][None ]._invm[eio_sid]\n  except KeyError:\n   pass\n   \n def eio_sid_from_sid(self,sid,namespace):\n  if namespace in self.rooms:\n   return self.rooms[namespace][None ].get(sid)\n   \n def can_disconnect(self,sid,namespace):\n  return self.is_connected(sid,namespace)\n  \n def pre_disconnect(self,sid,namespace):\n  ''\n\n\n\n\n  \n  if namespace not in self.pending_disconnect:\n   self.pending_disconnect[namespace]=[]\n  self.pending_disconnect[namespace].append(sid)\n  return self.rooms[namespace][None ].get(sid)\n  \n def disconnect(self,sid,namespace):\n  ''\n  if namespace not in self.rooms:\n   return\n  rooms=[]\n  for room_name,room in self.rooms[namespace].copy().items():\n   if sid in room:\n    rooms.append(room_name)\n  for room in rooms:\n   self.leave_room(sid,namespace,room)\n  if sid in self.callbacks:\n   del self.callbacks[sid]\n  if namespace in self.pending_disconnect and\\\n  sid in self.pending_disconnect[namespace]:\n   self.pending_disconnect[namespace].remove(sid)\n   if len(self.pending_disconnect[namespace])==0:\n    del self.pending_disconnect[namespace]\n    \n def enter_room(self,sid,namespace,room,eio_sid=None ):\n  ''\n  if eio_sid is None and namespace not in self.rooms:\n   raise ValueError('sid is not connected to requested namespace')\n  if namespace not in self.rooms:\n   self.rooms[namespace]={}\n  if room not in self.rooms[namespace]:\n   self.rooms[namespace][room]=bidict()\n  if eio_sid is None :\n   eio_sid=self.rooms[namespace][None ][sid]\n  self.rooms[namespace][room][sid]=eio_sid\n  \n def leave_room(self,sid,namespace,room):\n  ''\n  try :\n   del self.rooms[namespace][room][sid]\n   if len(self.rooms[namespace][room])==0:\n    del self.rooms[namespace][room]\n    if len(self.rooms[namespace])==0:\n     del self.rooms[namespace]\n  except KeyError:\n   pass\n   \n def close_room(self,room,namespace):\n  ''\n  try :\n   for sid,_ in self.get_participants(namespace,room):\n    self.leave_room(sid,namespace,room)\n  except KeyError:\n   pass\n   \n def get_rooms(self,sid,namespace):\n  ''\n  r=[]\n  try :\n   for room_name,room in self.rooms[namespace].items():\n    if room_name is not None and sid in room:\n     r.append(room_name)\n  except KeyError:\n   pass\n  return r\n  \n def emit(self,event,data,namespace,room=None ,skip_sid=None ,\n callback=None ,**kwargs):\n  ''\n  \n  if namespace not in self.rooms:\n   return\n  if not isinstance(skip_sid,list):\n   skip_sid=[skip_sid]\n  for sid,eio_sid in self.get_participants(namespace,room):\n   if sid not in skip_sid:\n    if callback is not None :\n     id=self._generate_ack_id(sid,callback)\n    else :\n     id=None\n    self.server._emit_internal(eio_sid,event,data,namespace,id)\n    \n def trigger_callback(self,sid,id,data):\n  ''\n  callback=None\n  try :\n   callback=self.callbacks[sid][id]\n  except KeyError:\n  \n   self._get_logger().warning('Unknown callback received, ignoring.')\n  else :\n   del self.callbacks[sid][id]\n  if callback is not None :\n   callback(*data)\n   \n def _generate_ack_id(self,sid,callback):\n  ''\n  if sid not in self.callbacks:\n   self.callbacks[sid]={0:itertools.count(1)}\n  id=next(self.callbacks[sid][0])\n  self.callbacks[sid][id]=callback\n  return id\n  \n def _get_logger(self):\n  ''\n\n\n  \n  \n  if self.logger:\n   return self.logger\n  elif self.server:\n   return self.server.logger\n  else :\n   return default_logger\n", ["bidict", "itertools", "logging"]], "socketio.client": [".py", "import itertools\nimport logging\nimport random\nimport signal\nimport threading\n\nimport engineio\n\nfrom . import exceptions\nfrom . import namespace\nfrom . import packet\n\ndefault_logger=logging.getLogger('socketio.client')\nreconnecting_clients=[]\n\n\ndef signal_handler(sig,frame):\n ''\n\n\n\n \n for client in reconnecting_clients[:]:\n  client._reconnect_abort.set()\n if callable(original_signal_handler):\n  return original_signal_handler(sig,frame)\n else :\n \n  return signal.default_int_handler(sig,frame)\n  \n  \noriginal_signal_handler=None\n\n\nclass Client(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n reserved_events=['connect','connect_error','disconnect']\n \n def __init__(self,reconnection=True ,reconnection_attempts=0,\n reconnection_delay=1,reconnection_delay_max=5,\n randomization_factor=0.5,logger=False ,serializer='default',\n json=None ,handle_sigint=True ,**kwargs):\n  global original_signal_handler\n  if handle_sigint and original_signal_handler is None and\\\n  threading.current_thread()==threading.main_thread():\n   original_signal_handler=signal.signal(signal.SIGINT,\n   signal_handler)\n  self.reconnection=reconnection\n  self.reconnection_attempts=reconnection_attempts\n  self.reconnection_delay=reconnection_delay\n  self.reconnection_delay_max=reconnection_delay_max\n  self.randomization_factor=randomization_factor\n  self.handle_sigint=handle_sigint\n  \n  engineio_options=kwargs\n  engineio_options['handle_sigint']=handle_sigint\n  engineio_logger=engineio_options.pop('engineio_logger',None )\n  if engineio_logger is not None :\n   engineio_options['logger']=engineio_logger\n  if serializer =='default':\n   self.packet_class=packet.Packet\n  elif serializer =='msgpack':\n   from . import msgpack_packet\n   self.packet_class=msgpack_packet.MsgPackPacket\n  else :\n   self.packet_class=serializer\n  if json is not None :\n   self.packet_class.json=json\n   engineio_options['json']=json\n   \n  self.eio=self._engineio_client_class()(**engineio_options)\n  self.eio.on('connect',self._handle_eio_connect)\n  self.eio.on('message',self._handle_eio_message)\n  self.eio.on('disconnect',self._handle_eio_disconnect)\n  \n  if not isinstance(logger,bool):\n   self.logger=logger\n  else :\n   self.logger=default_logger\n   if self.logger.level ==logging.NOTSET:\n    if logger:\n     self.logger.setLevel(logging.INFO)\n    else :\n     self.logger.setLevel(logging.ERROR)\n    self.logger.addHandler(logging.StreamHandler())\n    \n  self.connection_url=None\n  self.connection_headers=None\n  self.connection_auth=None\n  self.connection_transports=None\n  self.connection_namespaces=[]\n  self.socketio_path=None\n  self.sid=None\n  \n  self.connected=False\n  self.namespaces={}\n  self.handlers={}\n  self.namespace_handlers={}\n  self.callbacks={}\n  self._binary_packet=None\n  self._connect_event=None\n  self._reconnect_task=None\n  self._reconnect_abort=None\n  \n def is_asyncio_based(self):\n  return False\n  \n def on(self,event,handler=None ,namespace=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  \n  def set_handler(handler):\n   if namespace not in self.handlers:\n    self.handlers[namespace]={}\n   self.handlers[namespace][event]=handler\n   return handler\n   \n  if handler is None :\n   return set_handler\n  set_handler(handler)\n  \n def event(self,*args,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if len(args)==1 and len(kwargs)==0 and callable(args[0]):\n  \n  \n   return self.on(args[0].__name__)(args[0])\n  else :\n  \n   def set_handler(handler):\n    return self.on(handler.__name__,*args,**kwargs)(handler)\n    \n   return set_handler\n   \n def register_namespace(self,namespace_handler):\n  ''\n\n\n\n\n  \n  if not isinstance(namespace_handler,namespace.ClientNamespace):\n   raise ValueError('Not a namespace instance')\n  if self.is_asyncio_based()!=namespace_handler.is_asyncio_based():\n   raise ValueError('Not a valid namespace class for this client')\n  namespace_handler._set_client(self)\n  self.namespace_handlers[namespace_handler.namespace]=\\\n  namespace_handler\n  \n def connect(self,url,headers={},auth=None ,transports=None ,\n namespaces=None ,socketio_path='socket.io',wait=True ,\n wait_timeout=1):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self.connected:\n   raise exceptions.ConnectionError('Already connected')\n   \n  self.connection_url=url\n  self.connection_headers=headers\n  self.connection_auth=auth\n  self.connection_transports=transports\n  self.connection_namespaces=namespaces\n  self.socketio_path=socketio_path\n  \n  if namespaces is None :\n   namespaces=list(set(self.handlers.keys()).union(\n   set(self.namespace_handlers.keys())))\n   if len(namespaces)==0:\n    namespaces=['/']\n  elif isinstance(namespaces,str):\n   namespaces=[namespaces]\n  self.connection_namespaces=namespaces\n  self.namespaces={}\n  if self._connect_event is None :\n   self._connect_event=self.eio.create_event()\n  else :\n   self._connect_event.clear()\n  real_url=self._get_real_value(self.connection_url)\n  real_headers=self._get_real_value(self.connection_headers)\n  try :\n   self.eio.connect(real_url,headers=real_headers,\n   transports=transports,\n   engineio_path=socketio_path)\n  except engineio.exceptions.ConnectionError as exc:\n   self._trigger_event(\n   'connect_error','/',\n   exc.args[1]if len(exc.args)>1 else exc.args[0])\n   raise exceptions.ConnectionError(exc.args[0])from None\n   \n  if wait:\n   while self._connect_event.wait(timeout=wait_timeout):\n    self._connect_event.clear()\n    if set(self.namespaces)==set(self.connection_namespaces):\n     break\n   if set(self.namespaces)!=set(self.connection_namespaces):\n    self.disconnect()\n    raise exceptions.ConnectionError(\n    'One or more namespaces failed to connect')\n    \n  self.connected=True\n  \n def wait(self):\n  ''\n\n\n\n  \n  while True :\n   self.eio.wait()\n   self.sleep(1)\n   if not self._reconnect_task:\n    break\n   self._reconnect_task.join()\n   if self.eio.state !='connected':\n    break\n    \n def emit(self,event,data=None ,namespace=None ,callback=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  if namespace not in self.namespaces:\n   raise exceptions.BadNamespaceError(\n   namespace+' is not a connected namespace.')\n  self.logger.info('Emitting event \"%s\" [%s]',event,namespace)\n  if callback is not None :\n   id=self._generate_ack_id(namespace,callback)\n  else :\n   id=None\n   \n   \n  if isinstance(data,tuple):\n   data=list(data)\n  elif data is not None :\n   data=[data]\n  else :\n   data=[]\n  self._send_packet(self.packet_class(packet.EVENT,namespace=namespace,\n  data=[event]+data,id=id))\n  \n def send(self,data,namespace=None ,callback=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.emit('message',data=data,namespace=namespace,\n  callback=callback)\n  \n def call(self,event,data=None ,namespace=None ,timeout=60):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  callback_event=self.eio.create_event()\n  callback_args=[]\n  \n  def event_callback(*args):\n   callback_args.append(args)\n   callback_event.set()\n   \n  self.emit(event,data=data,namespace=namespace,\n  callback=event_callback)\n  if not callback_event.wait(timeout=timeout):\n   raise exceptions.TimeoutError()\n  return callback_args[0]if len(callback_args[0])>1\\\n  else callback_args[0][0]if len(callback_args[0])==1\\\n  else None\n  \n def disconnect(self):\n  ''\n  \n  \n  for n in self.namespaces:\n   self._send_packet(self.packet_class(\n   packet.DISCONNECT,namespace=n))\n  self.eio.disconnect(abort=True )\n  \n def get_sid(self,namespace=None ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  return self.namespaces.get(namespace or '/')\n  \n def transport(self):\n  ''\n\n\n\n  \n  return self.eio.transport()\n  \n def start_background_task(self,target,*args,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return self.eio.start_background_task(target,*args,**kwargs)\n  \n def sleep(self,seconds=0):\n  ''\n\n\n\n\n\n  \n  return self.eio.sleep(seconds)\n  \n def _get_real_value(self,value):\n  ''\n  \n  if not callable(value):\n   return value\n  return value()\n  \n def _send_packet(self,pkt):\n  ''\n  encoded_packet=pkt.encode()\n  if isinstance(encoded_packet,list):\n   for ep in encoded_packet:\n    self.eio.send(ep)\n  else :\n   self.eio.send(encoded_packet)\n   \n def _generate_ack_id(self,namespace,callback):\n  ''\n  namespace=namespace or '/'\n  if namespace not in self.callbacks:\n   self.callbacks[namespace]={0:itertools.count(1)}\n  id=next(self.callbacks[namespace][0])\n  self.callbacks[namespace][id]=callback\n  return id\n  \n def _handle_connect(self,namespace,data):\n  namespace=namespace or '/'\n  if namespace not in self.namespaces:\n   self.logger.info('Namespace {} is connected'.format(namespace))\n   self.namespaces[namespace]=(data or {}).get('sid',self.sid)\n   self._trigger_event('connect',namespace=namespace)\n   self._connect_event.set()\n   \n def _handle_disconnect(self,namespace):\n  if not self.connected:\n   return\n  namespace=namespace or '/'\n  self._trigger_event('disconnect',namespace=namespace)\n  if namespace in self.namespaces:\n   del self.namespaces[namespace]\n  if not self.namespaces:\n   self.connected=False\n   self.eio.disconnect(abort=True )\n   \n def _handle_event(self,namespace,id,data):\n  namespace=namespace or '/'\n  self.logger.info('Received event \"%s\" [%s]',data[0],namespace)\n  r=self._trigger_event(data[0],namespace,*data[1:])\n  if id is not None :\n  \n  \n   if r is None :\n    data=[]\n   elif isinstance(r,tuple):\n    data=list(r)\n   else :\n    data=[r]\n   self._send_packet(self.packet_class(\n   packet.ACK,namespace=namespace,id=id,data=data))\n   \n def _handle_ack(self,namespace,id,data):\n  namespace=namespace or '/'\n  self.logger.info('Received ack [%s]',namespace)\n  callback=None\n  try :\n   callback=self.callbacks[namespace][id]\n  except KeyError:\n  \n   self.logger.warning('Unknown callback received, ignoring.')\n  else :\n   del self.callbacks[namespace][id]\n  if callback is not None :\n   callback(*data)\n   \n def _handle_error(self,namespace,data):\n  namespace=namespace or '/'\n  self.logger.info('Connection to namespace {} was rejected'.format(\n  namespace))\n  if data is None :\n   data=tuple()\n  elif not isinstance(data,(tuple,list)):\n   data=(data,)\n  self._trigger_event('connect_error',namespace,*data)\n  self._connect_event.set()\n  if namespace in self.namespaces:\n   del self.namespaces[namespace]\n  if namespace =='/':\n   self.namespaces={}\n   self.connected=False\n   \n def _trigger_event(self,event,namespace,*args):\n  ''\n  \n  if namespace in self.handlers:\n   if event in self.handlers[namespace]:\n    return self.handlers[namespace][event](*args)\n   elif event not in self.reserved_events and\\\n   '*'in self.handlers[namespace]:\n    return self.handlers[namespace]['*'](event,*args)\n    \n    \n  elif namespace in self.namespace_handlers:\n   return self.namespace_handlers[namespace].trigger_event(\n   event,*args)\n   \n def _handle_reconnect(self):\n  if self._reconnect_abort is None :\n   self._reconnect_abort=self.eio.create_event()\n  self._reconnect_abort.clear()\n  reconnecting_clients.append(self)\n  attempt_count=0\n  current_delay=self.reconnection_delay\n  while True :\n   delay=current_delay\n   current_delay *=2\n   if delay >self.reconnection_delay_max:\n    delay=self.reconnection_delay_max\n   delay +=self.randomization_factor *(2 *random.random()-1)\n   self.logger.info(\n   'Connection failed, new attempt in {:.02f} seconds'.format(\n   delay))\n   if self._reconnect_abort.wait(delay):\n    self.logger.info('Reconnect task aborted')\n    break\n   attempt_count +=1\n   try :\n    self.connect(self.connection_url,\n    headers=self.connection_headers,\n    auth=self.connection_auth,\n    transports=self.connection_transports,\n    namespaces=self.connection_namespaces,\n    socketio_path=self.socketio_path)\n   except (exceptions.ConnectionError,ValueError):\n    pass\n   else :\n    self.logger.info('Reconnection successful')\n    self._reconnect_task=None\n    break\n   if self.reconnection_attempts and\\\n   attempt_count >=self.reconnection_attempts:\n    self.logger.info(\n    'Maximum reconnection attempts reached, giving up')\n    break\n  reconnecting_clients.remove(self)\n  \n def _handle_eio_connect(self):\n  ''\n  self.logger.info('Engine.IO connection established')\n  self.sid=self.eio.sid\n  real_auth=self._get_real_value(self.connection_auth)or {}\n  for n in self.connection_namespaces:\n   self._send_packet(self.packet_class(\n   packet.CONNECT,data=real_auth,namespace=n))\n   \n def _handle_eio_message(self,data):\n  ''\n  if self._binary_packet:\n   pkt=self._binary_packet\n   if pkt.add_attachment(data):\n    self._binary_packet=None\n    if pkt.packet_type ==packet.BINARY_EVENT:\n     self._handle_event(pkt.namespace,pkt.id,pkt.data)\n    else :\n     self._handle_ack(pkt.namespace,pkt.id,pkt.data)\n  else :\n   pkt=self.packet_class(encoded_packet=data)\n   if pkt.packet_type ==packet.CONNECT:\n    self._handle_connect(pkt.namespace,pkt.data)\n   elif pkt.packet_type ==packet.DISCONNECT:\n    self._handle_disconnect(pkt.namespace)\n   elif pkt.packet_type ==packet.EVENT:\n    self._handle_event(pkt.namespace,pkt.id,pkt.data)\n   elif pkt.packet_type ==packet.ACK:\n    self._handle_ack(pkt.namespace,pkt.id,pkt.data)\n   elif pkt.packet_type ==packet.BINARY_EVENT or\\\n   pkt.packet_type ==packet.BINARY_ACK:\n    self._binary_packet=pkt\n   elif pkt.packet_type ==packet.CONNECT_ERROR:\n    self._handle_error(pkt.namespace,pkt.data)\n   else :\n    raise ValueError('Unknown packet type.')\n    \n def _handle_eio_disconnect(self):\n  ''\n  self.logger.info('Engine.IO connection dropped')\n  if self.connected:\n   for n in self.namespaces:\n    self._trigger_event('disconnect',namespace=n)\n   self.namespaces={}\n   self.connected=False\n  self.callbacks={}\n  self._binary_packet=None\n  self.sid=None\n  if self.eio.state =='connected'and self.reconnection:\n   self._reconnect_task=self.start_background_task(\n   self._handle_reconnect)\n   \n def _engineio_client_class(self):\n  return engineio.Client\n", ["engineio", "itertools", "logging", "random", "signal", "socketio", "threading"]], "socketio.exceptions": [".py", "class SocketIOError(Exception):\n pass\n \n \nclass ConnectionError(SocketIOError):\n pass\n \n \nclass ConnectionRefusedError(ConnectionError):\n ''\n\n\n\n\n \n def __init__(self,*args):\n  if len(args)==0:\n   self.error_args={'message':'Connection rejected by server'}\n  elif len(args)==1:\n   self.error_args={'message':str(args[0])}\n  else :\n   self.error_args={'message':str(args[0])}\n   if len(args)==2:\n    self.error_args['data']=args[1]\n   else :\n    self.error_args['data']=args[1:]\n    \n    \nclass TimeoutError(SocketIOError):\n pass\n \n \nclass BadNamespaceError(SocketIOError):\n pass\n", []], "socketio.kafka_manager": [".py", "import logging\nimport pickle\n\ntry :\n import kafka\nexcept ImportError:\n kafka=None\n \nfrom .pubsub_manager import PubSubManager\n\nlogger=logging.getLogger('socketio')\n\n\nclass KafkaManager(PubSubManager):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name='kafka'\n \n def __init__(self,url='kafka://localhost:9092',channel='socketio',\n write_only=False ):\n  if kafka is None :\n   raise RuntimeError('kafka-python package is not installed '\n   '(Run \"pip install kafka-python\" in your '\n   'virtualenv).')\n   \n  super(KafkaManager,self).__init__(channel=channel,\n  write_only=write_only)\n  \n  urls=[url]if isinstance(url,str)else url\n  self.kafka_urls=[url[8:]if url !='kafka://'else 'localhost:9092'\n  for url in urls]\n  self.producer=kafka.KafkaProducer(bootstrap_servers=self.kafka_urls)\n  self.consumer=kafka.KafkaConsumer(self.channel,\n  bootstrap_servers=self.kafka_urls)\n  \n def _publish(self,data):\n  self.producer.send(self.channel,value=pickle.dumps(data))\n  self.producer.flush()\n  \n def _kafka_listen(self):\n  for message in self.consumer:\n   yield message\n   \n def _listen(self):\n  for message in self._kafka_listen():\n   if message.topic ==self.channel:\n    yield pickle.loads(message.value)\n", ["kafka", "logging", "pickle", "socketio.pubsub_manager"]], "socketio.kombu_manager": [".py", "import pickle\nimport uuid\n\ntry :\n import kombu\nexcept ImportError:\n kombu=None\n \nfrom .pubsub_manager import PubSubManager\n\n\nclass KombuManager(PubSubManager):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name='kombu'\n \n def __init__(self,url='amqp://guest:guest@localhost:5672//',\n channel='socketio',write_only=False ,logger=None ,\n connection_options=None ,exchange_options=None ,\n queue_options=None ,producer_options=None ):\n  if kombu is None :\n   raise RuntimeError('Kombu package is not installed '\n   '(Run \"pip install kombu\" in your '\n   'virtualenv).')\n  super(KombuManager,self).__init__(channel=channel,\n  write_only=write_only,\n  logger=logger)\n  self.url=url\n  self.connection_options=connection_options or {}\n  self.exchange_options=exchange_options or {}\n  self.queue_options=queue_options or {}\n  self.producer_options=producer_options or {}\n  self.producer=self._producer()\n  \n def initialize(self):\n  super(KombuManager,self).initialize()\n  \n  monkey_patched=True\n  if self.server.async_mode =='eventlet':\n   from eventlet.patcher import is_monkey_patched\n   monkey_patched=is_monkey_patched('socket')\n  elif 'gevent'in self.server.async_mode:\n   from gevent.monkey import is_module_patched\n   monkey_patched=is_module_patched('socket')\n  if not monkey_patched:\n   raise RuntimeError(\n   'Kombu requires a monkey patched socket library to work '\n   'with '+self.server.async_mode)\n   \n def _connection(self):\n  return kombu.Connection(self.url,**self.connection_options)\n  \n def _exchange(self):\n  options={'type':'fanout','durable':False }\n  options.update(self.exchange_options)\n  return kombu.Exchange(self.channel,**options)\n  \n def _queue(self):\n  queue_name='flask-socketio.'+str(uuid.uuid4())\n  options={'durable':False ,'queue_arguments':{'x-expires':300000}}\n  options.update(self.queue_options)\n  return kombu.Queue(queue_name,self._exchange(),**options)\n  \n def _producer(self):\n  return self._connection().Producer(exchange=self._exchange(),\n  **self.producer_options)\n  \n def __error_callback(self,exception,interval):\n  self._get_logger().exception('Sleeping {}s'.format(interval))\n  \n def _publish(self,data):\n  connection=self._connection()\n  publish=connection.ensure(self.producer,self.producer.publish,\n  errback=self.__error_callback)\n  publish(pickle.dumps(data))\n  \n def _listen(self):\n  reader_queue=self._queue()\n  \n  while True :\n   connection=self._connection().ensure_connection(\n   errback=self.__error_callback)\n   try :\n    with connection.SimpleQueue(reader_queue)as queue:\n     while True :\n      message=queue.get(block=True )\n      message.ack()\n      yield message.payload\n   except connection.connection_errors:\n    self._get_logger().exception(\"Connection error \"\n    \"while reading from queue\")\n", ["eventlet.patcher", "gevent.monkey", "kombu", "pickle", "socketio.pubsub_manager", "uuid"]], "socketio.middleware": [".py", "import engineio\n\n\nclass WSGIApp(engineio.WSGIApp):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,socketio_app,wsgi_app=None ,static_files=None ,\n socketio_path='socket.io'):\n  super(WSGIApp,self).__init__(socketio_app,wsgi_app,\n  static_files=static_files,\n  engineio_path=socketio_path)\n  \n  \nclass Middleware(WSGIApp):\n ''\n def __init__(self,socketio_app,wsgi_app=None ,\n socketio_path='socket.io'):\n  super(Middleware,self).__init__(socketio_app,wsgi_app,\n  socketio_path=socketio_path)\n", ["engineio"]], "socketio.msgpack_packet": [".py", "import msgpack\nfrom . import packet\n\n\nclass MsgPackPacket(packet.Packet):\n uses_binary_events=False\n \n def encode(self):\n  ''\n  return msgpack.dumps(self._to_dict())\n  \n def decode(self,encoded_packet):\n  ''\n  decoded=msgpack.loads(encoded_packet)\n  self.packet_type=decoded['type']\n  self.data=decoded['data']\n  self.id=decoded.get('id')\n  self.namespace=decoded['nsp']\n", ["msgpack", "socketio"]], "socketio.namespace": [".py", "class BaseNamespace(object):\n def __init__(self,namespace=None ):\n  self.namespace=namespace or '/'\n  \n def is_asyncio_based(self):\n  return False\n  \n def trigger_event(self,event,*args):\n  ''\n\n\n\n\n\n  \n  handler_name='on_'+event\n  if hasattr(self,handler_name):\n   return getattr(self,handler_name)(*args)\n   \n   \nclass Namespace(BaseNamespace):\n ''\n\n\n\n\n\n\n\n\n\n \n def __init__(self,namespace=None ):\n  super(Namespace,self).__init__(namespace=namespace)\n  self.server=None\n  \n def _set_server(self,server):\n  self.server=server\n  \n def emit(self,event,data=None ,to=None ,room=None ,skip_sid=None ,\n namespace=None ,callback=None ):\n  ''\n\n\n\n\n  \n  return self.server.emit(event,data=data,to=to,room=room,\n  skip_sid=skip_sid,\n  namespace=namespace or self.namespace,\n  callback=callback)\n  \n def send(self,data,to=None ,room=None ,skip_sid=None ,namespace=None ,\n callback=None ):\n  ''\n\n\n\n\n  \n  return self.server.send(data,to=to,room=room,skip_sid=skip_sid,\n  namespace=namespace or self.namespace,\n  callback=callback)\n  \n def call(self,event,data=None ,to=None ,sid=None ,namespace=None ,\n timeout=None ):\n  ''\n\n\n\n\n  \n  return self.server.call(event,data=data,to=to,sid=sid,\n  namespace=namespace or self.namespace,\n  timeout=timeout)\n  \n def enter_room(self,sid,room,namespace=None ):\n  ''\n\n\n\n\n  \n  return self.server.enter_room(sid,room,\n  namespace=namespace or self.namespace)\n  \n def leave_room(self,sid,room,namespace=None ):\n  ''\n\n\n\n\n  \n  return self.server.leave_room(sid,room,\n  namespace=namespace or self.namespace)\n  \n def close_room(self,room,namespace=None ):\n  ''\n\n\n\n\n  \n  return self.server.close_room(room,\n  namespace=namespace or self.namespace)\n  \n def rooms(self,sid,namespace=None ):\n  ''\n\n\n\n\n  \n  return self.server.rooms(sid,namespace=namespace or self.namespace)\n  \n def get_session(self,sid,namespace=None ):\n  ''\n\n\n\n\n  \n  return self.server.get_session(\n  sid,namespace=namespace or self.namespace)\n  \n def save_session(self,sid,session,namespace=None ):\n  ''\n\n\n\n\n  \n  return self.server.save_session(\n  sid,session,namespace=namespace or self.namespace)\n  \n def session(self,sid,namespace=None ):\n  ''\n\n\n\n\n  \n  return self.server.session(sid,namespace=namespace or self.namespace)\n  \n def disconnect(self,sid,namespace=None ):\n  ''\n\n\n\n\n  \n  return self.server.disconnect(sid,\n  namespace=namespace or self.namespace)\n  \n  \nclass ClientNamespace(BaseNamespace):\n ''\n\n\n\n\n\n\n\n\n\n \n def __init__(self,namespace=None ):\n  super(ClientNamespace,self).__init__(namespace=namespace)\n  self.client=None\n  \n def _set_client(self,client):\n  self.client=client\n  \n def emit(self,event,data=None ,namespace=None ,callback=None ):\n  ''\n\n\n\n\n  \n  return self.client.emit(event,data=data,\n  namespace=namespace or self.namespace,\n  callback=callback)\n  \n def send(self,data,room=None ,namespace=None ,callback=None ):\n  ''\n\n\n\n\n  \n  return self.client.send(data,namespace=namespace or self.namespace,\n  callback=callback)\n  \n def call(self,event,data=None ,namespace=None ,timeout=None ):\n  ''\n\n\n\n\n  \n  return self.client.call(event,data=data,\n  namespace=namespace or self.namespace,\n  timeout=timeout)\n  \n def disconnect(self):\n  ''\n\n\n\n\n  \n  return self.client.disconnect()\n", []], "socketio.packet": [".py", "import functools\nfrom engineio import json as _json\n\n(CONNECT,DISCONNECT,EVENT,ACK,CONNECT_ERROR,BINARY_EVENT,BINARY_ACK)=\\\n(0,1,2,3,4,5,6)\npacket_names=['CONNECT','DISCONNECT','EVENT','ACK','CONNECT_ERROR',\n'BINARY_EVENT','BINARY_ACK']\n\n\nclass Packet(object):\n ''\n \n \n \n \n \n \n \n \n \n \n uses_binary_events=True\n json=_json\n \n def __init__(self,packet_type=EVENT,data=None ,namespace=None ,id=None ,\n binary=None ,encoded_packet=None ):\n  self.packet_type=packet_type\n  self.data=data\n  self.namespace=namespace\n  self.id=id\n  if self.uses_binary_events and\\\n  (binary or (binary is None and self._data_is_binary(\n  self.data))):\n   if self.packet_type ==EVENT:\n    self.packet_type=BINARY_EVENT\n   elif self.packet_type ==ACK:\n    self.packet_type=BINARY_ACK\n   else :\n    raise ValueError('Packet does not support binary payload.')\n  self.attachment_count=0\n  self.attachments=[]\n  if encoded_packet:\n   self.attachment_count=self.decode(encoded_packet)or 0\n   \n def encode(self):\n  ''\n\n\n\n\n  \n  encoded_packet=str(self.packet_type)\n  if self.packet_type ==BINARY_EVENT or self.packet_type ==BINARY_ACK:\n   data,attachments=self._deconstruct_binary(self.data)\n   encoded_packet +=str(len(attachments))+'-'\n  else :\n   data=self.data\n   attachments=None\n  if self.namespace is not None and self.namespace !='/':\n   encoded_packet +=self.namespace+','\n  if self.id is not None :\n   encoded_packet +=str(self.id)\n  if data is not None :\n   encoded_packet +=self.json.dumps(data,separators=(',',':'))\n  if attachments is not None :\n   encoded_packet=[encoded_packet]+attachments\n  return encoded_packet\n  \n def decode(self,encoded_packet):\n  ''\n\n\n\n  \n  ep=encoded_packet\n  try :\n   self.packet_type=int(ep[0:1])\n  except TypeError:\n   self.packet_type=ep\n   ep=''\n  self.namespace=None\n  self.data=None\n  ep=ep[1:]\n  dash=ep.find('-')\n  attachment_count=0\n  if dash >0 and ep[0:dash].isdigit():\n   if dash >10:\n    raise ValueError('too many attachments')\n   attachment_count=int(ep[0:dash])\n   ep=ep[dash+1:]\n  if ep and ep[0:1]=='/':\n   sep=ep.find(',')\n   if sep ==-1:\n    self.namespace=ep\n    ep=''\n   else :\n    self.namespace=ep[0:sep]\n    ep=ep[sep+1:]\n   q=self.namespace.find('?')\n   if q !=-1:\n    self.namespace=self.namespace[0:q]\n  if ep and ep[0].isdigit():\n   i=1\n   end=len(ep)\n   while i <end:\n    if not ep[i].isdigit()or i >=100:\n     break\n    i +=1\n   self.id=int(ep[:i])\n   ep=ep[i:]\n   if len(ep)>0 and ep[0].isdigit():\n    raise ValueError('id field is too long')\n  if ep:\n   self.data=self.json.loads(ep)\n  return attachment_count\n  \n def add_attachment(self,attachment):\n  if self.attachment_count <=len(self.attachments):\n   raise ValueError('Unexpected binary attachment')\n  self.attachments.append(attachment)\n  if self.attachment_count ==len(self.attachments):\n   self.reconstruct_binary(self.attachments)\n   return True\n  return False\n  \n def reconstruct_binary(self,attachments):\n  ''\n\n  \n  self.data=self._reconstruct_binary_internal(self.data,\n  self.attachments)\n  \n def _reconstruct_binary_internal(self,data,attachments):\n  if isinstance(data,list):\n   return [self._reconstruct_binary_internal(item,attachments)\n   for item in data]\n  elif isinstance(data,dict):\n   if data.get('_placeholder')and 'num'in data:\n    return attachments[data['num']]\n   else :\n    return {key:self._reconstruct_binary_internal(value,\n    attachments)\n    for key,value in data.items()}\n  else :\n   return data\n   \n def _deconstruct_binary(self,data):\n  ''\n  attachments=[]\n  data=self._deconstruct_binary_internal(data,attachments)\n  return data,attachments\n  \n def _deconstruct_binary_internal(self,data,attachments):\n  if isinstance(data,bytes):\n   attachments.append(data)\n   return {'_placeholder':True ,'num':len(attachments)-1}\n  elif isinstance(data,list):\n   return [self._deconstruct_binary_internal(item,attachments)\n   for item in data]\n  elif isinstance(data,dict):\n   return {key:self._deconstruct_binary_internal(value,attachments)\n   for key,value in data.items()}\n  else :\n   return data\n   \n def _data_is_binary(self,data):\n  ''\n  if isinstance(data,bytes):\n   return True\n  elif isinstance(data,list):\n   return functools.reduce(\n   lambda a,b:a or b,[self._data_is_binary(item)\n   for item in data],False )\n  elif isinstance(data,dict):\n   return functools.reduce(\n   lambda a,b:a or b,[self._data_is_binary(item)\n   for item in data.values()],\n   False )\n  else :\n   return False\n   \n def _to_dict(self):\n  d={\n  'type':self.packet_type,\n  'data':self.data,\n  'nsp':self.namespace,\n  }\n  if self.id:\n   d['id']=self.id\n  return d\n", ["engineio", "functools"]], "socketio.pubsub_manager": [".py", "from functools import partial\nimport uuid\n\nfrom engineio import json\nimport pickle\n\nfrom .base_manager import BaseManager\n\n\nclass PubSubManager(BaseManager):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n name='pubsub'\n \n def __init__(self,channel='socketio',write_only=False ,logger=None ):\n  super(PubSubManager,self).__init__()\n  self.channel=channel\n  self.write_only=write_only\n  self.host_id=uuid.uuid4().hex\n  self.logger=logger\n  \n def initialize(self):\n  super(PubSubManager,self).initialize()\n  if not self.write_only:\n   self.thread=self.server.start_background_task(self._thread)\n  self._get_logger().info(self.name+' backend initialized.')\n  \n def emit(self,event,data,namespace=None ,room=None ,skip_sid=None ,\n callback=None ,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  if kwargs.get('ignore_queue'):\n   return super(PubSubManager,self).emit(\n   event,data,namespace=namespace,room=room,skip_sid=skip_sid,\n   callback=callback)\n  namespace=namespace or '/'\n  if callback is not None :\n   if self.server is None :\n    raise RuntimeError('Callbacks can only be issued from the '\n    'context of a server.')\n   if room is None :\n    raise ValueError('Cannot use callback without a room set.')\n   id=self._generate_ack_id(room,callback)\n   callback=(room,namespace,id)\n  else :\n   callback=None\n  self._publish({'method':'emit','event':event,'data':data,\n  'namespace':namespace,'room':room,\n  'skip_sid':skip_sid,'callback':callback,\n  'host_id':self.host_id})\n  \n def can_disconnect(self,sid,namespace):\n  if self.is_connected(sid,namespace):\n  \n   return super().can_disconnect(sid,namespace)\n  else :\n  \n   self._publish({'method':'disconnect','sid':sid,\n   'namespace':namespace or '/'})\n   \n def disconnect(self,sid,namespace=None ):\n  self._publish({'method':'disconnect','sid':sid,\n  'namespace':namespace or '/'})\n  \n def close_room(self,room,namespace=None ):\n  self._publish({'method':'close_room','room':room,\n  'namespace':namespace or '/'})\n  \n def _publish(self,data):\n  ''\n\n\n\n  \n  raise NotImplementedError('This method must be implemented in a '\n  'subclass.')\n  \n def _listen(self):\n  ''\n\n\n\n\n  \n  raise NotImplementedError('This method must be implemented in a '\n  'subclass.')\n  \n def _handle_emit(self,message):\n \n \n \n  remote_callback=message.get('callback')\n  remote_host_id=message.get('host_id')\n  if remote_callback is not None and len(remote_callback)==3:\n   callback=partial(self._return_callback,remote_host_id,\n   *remote_callback)\n  else :\n   callback=None\n  super(PubSubManager,self).emit(message['event'],message['data'],\n  namespace=message.get('namespace'),\n  room=message.get('room'),\n  skip_sid=message.get('skip_sid'),\n  callback=callback)\n  \n def _handle_callback(self,message):\n  if self.host_id ==message.get('host_id'):\n   try :\n    sid=message['sid']\n    id=message['id']\n    args=message['args']\n   except KeyError:\n    return\n   self.trigger_callback(sid,id,args)\n   \n def _return_callback(self,host_id,sid,namespace,callback_id,*args):\n \n \n  self._publish({'method':'callback','host_id':host_id,\n  'sid':sid,'namespace':namespace,'id':callback_id,\n  'args':args})\n  \n def _handle_disconnect(self,message):\n  self.server.disconnect(sid=message.get('sid'),\n  namespace=message.get('namespace'),\n  ignore_queue=True )\n  \n def _handle_close_room(self,message):\n  super(PubSubManager,self).close_room(\n  room=message.get('room'),namespace=message.get('namespace'))\n  \n def _thread(self):\n  for message in self._listen():\n   data=None\n   if isinstance(message,dict):\n    data=message\n   else :\n    if isinstance(message,bytes):\n     try :\n      data=pickle.loads(message)\n     except :\n      pass\n    if data is None :\n     try :\n      data=json.loads(message)\n     except :\n      pass\n   if data and 'method'in data:\n    self._get_logger().info('pubsub message: {}'.format(\n    data['method']))\n    try :\n     if data['method']=='emit':\n      self._handle_emit(data)\n     elif data['method']=='callback':\n      self._handle_callback(data)\n     elif data['method']=='disconnect':\n      self._handle_disconnect(data)\n     elif data['method']=='close_room':\n      self._handle_close_room(data)\n    except :\n     self.server.logger.exception(\n     'Unknown error in pubsub listening thread')\n", ["engineio", "functools", "pickle", "socketio.base_manager", "uuid"]], "socketio.redis_manager": [".py", "import logging\nimport pickle\nimport time\n\ntry :\n import redis\nexcept ImportError:\n redis=None\n \nfrom .pubsub_manager import PubSubManager\n\nlogger=logging.getLogger('socketio')\n\n\nclass RedisManager(PubSubManager):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name='redis'\n \n def __init__(self,url='redis://localhost:6379/0',channel='socketio',\n write_only=False ,logger=None ,redis_options=None ):\n  if redis is None :\n   raise RuntimeError('Redis package is not installed '\n   '(Run \"pip install redis\" in your '\n   'virtualenv).')\n  self.redis_url=url\n  self.redis_options=redis_options or {}\n  self._redis_connect()\n  super(RedisManager,self).__init__(channel=channel,\n  write_only=write_only,\n  logger=logger)\n  \n def initialize(self):\n  super(RedisManager,self).initialize()\n  \n  monkey_patched=True\n  if self.server.async_mode =='eventlet':\n   from eventlet.patcher import is_monkey_patched\n   monkey_patched=is_monkey_patched('socket')\n  elif 'gevent'in self.server.async_mode:\n   from gevent.monkey import is_module_patched\n   monkey_patched=is_module_patched('socket')\n  if not monkey_patched:\n   raise RuntimeError(\n   'Redis requires a monkey patched socket library to work '\n   'with '+self.server.async_mode)\n   \n def _redis_connect(self):\n  self.redis=redis.Redis.from_url(self.redis_url,\n  **self.redis_options)\n  self.pubsub=self.redis.pubsub(ignore_subscribe_messages=True )\n  \n def _publish(self,data):\n  retry=True\n  while True :\n   try :\n    if not retry:\n     self._redis_connect()\n    return self.redis.publish(self.channel,pickle.dumps(data))\n   except redis.exceptions.RedisError:\n    if retry:\n     logger.error('Cannot publish to redis... retrying')\n     retry=False\n    else :\n     logger.error('Cannot publish to redis... giving up')\n     break\n     \n def _redis_listen_with_retries(self):\n  retry_sleep=1\n  connect=False\n  while True :\n   try :\n    if connect:\n     self._redis_connect()\n     self.pubsub.subscribe(self.channel)\n     retry_sleep=1\n    for message in self.pubsub.listen():\n     yield message\n   except redis.exceptions.RedisError:\n    logger.error('Cannot receive from redis... '\n    'retrying in {} secs'.format(retry_sleep))\n    connect=True\n    time.sleep(retry_sleep)\n    retry_sleep *=2\n    if retry_sleep >60:\n     retry_sleep=60\n     \n def _listen(self):\n  channel=self.channel.encode('utf-8')\n  self.pubsub.subscribe(self.channel)\n  for message in self._redis_listen_with_retries():\n   if message['channel']==channel and\\\n   message['type']=='message'and 'data'in message:\n    yield message['data']\n  self.pubsub.unsubscribe(self.channel)\n", ["eventlet.patcher", "gevent.monkey", "logging", "pickle", "redis", "socketio.pubsub_manager", "time"]], "socketio.server": [".py", "import logging\n\nimport engineio\n\nfrom . import base_manager\nfrom . import exceptions\nfrom . import namespace\nfrom . import packet\n\ndefault_logger=logging.getLogger('socketio.server')\n\n\nclass Server(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n reserved_events=['connect','disconnect']\n \n def __init__(self,client_manager=None ,logger=False ,serializer='default',\n json=None ,async_handlers=True ,always_connect=False ,\n **kwargs):\n  engineio_options=kwargs\n  engineio_logger=engineio_options.pop('engineio_logger',None )\n  if engineio_logger is not None :\n   engineio_options['logger']=engineio_logger\n  if serializer =='default':\n   self.packet_class=packet.Packet\n  elif serializer =='msgpack':\n   from . import msgpack_packet\n   self.packet_class=msgpack_packet.MsgPackPacket\n  else :\n   self.packet_class=serializer\n  if json is not None :\n   self.packet_class.json=json\n   engineio_options['json']=json\n  engineio_options['async_handlers']=False\n  self.eio=self._engineio_server_class()(**engineio_options)\n  self.eio.on('connect',self._handle_eio_connect)\n  self.eio.on('message',self._handle_eio_message)\n  self.eio.on('disconnect',self._handle_eio_disconnect)\n  \n  self.environ={}\n  self.handlers={}\n  self.namespace_handlers={}\n  self.not_handled=object()\n  \n  self._binary_packet={}\n  \n  if not isinstance(logger,bool):\n   self.logger=logger\n  else :\n   self.logger=default_logger\n   if self.logger.level ==logging.NOTSET:\n    if logger:\n     self.logger.setLevel(logging.INFO)\n    else :\n     self.logger.setLevel(logging.ERROR)\n    self.logger.addHandler(logging.StreamHandler())\n    \n  if client_manager is None :\n   client_manager=base_manager.BaseManager()\n  self.manager=client_manager\n  self.manager.set_server(self)\n  self.manager_initialized=False\n  \n  self.async_handlers=async_handlers\n  self.always_connect=always_connect\n  \n  self.async_mode=self.eio.async_mode\n  \n def is_asyncio_based(self):\n  return False\n  \n def on(self,event,handler=None ,namespace=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  \n  def set_handler(handler):\n   if namespace not in self.handlers:\n    self.handlers[namespace]={}\n   self.handlers[namespace][event]=handler\n   return handler\n   \n  if handler is None :\n   return set_handler\n  set_handler(handler)\n  \n def event(self,*args,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if len(args)==1 and len(kwargs)==0 and callable(args[0]):\n  \n  \n   return self.on(args[0].__name__)(args[0])\n  else :\n  \n   def set_handler(handler):\n    return self.on(handler.__name__,*args,**kwargs)(handler)\n    \n   return set_handler\n   \n def register_namespace(self,namespace_handler):\n  ''\n\n\n\n\n  \n  if not isinstance(namespace_handler,namespace.Namespace):\n   raise ValueError('Not a namespace instance')\n  if self.is_asyncio_based()!=namespace_handler.is_asyncio_based():\n   raise ValueError('Not a valid namespace class for this server')\n  namespace_handler._set_server(self)\n  self.namespace_handlers[namespace_handler.namespace]=\\\n  namespace_handler\n  \n def emit(self,event,data=None ,to=None ,room=None ,skip_sid=None ,\n namespace=None ,callback=None ,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  room=to or room\n  self.logger.info('emitting event \"%s\" to %s [%s]',event,\n  room or 'all',namespace)\n  self.manager.emit(event,data,namespace,room=room,\n  skip_sid=skip_sid,callback=callback,**kwargs)\n  \n def send(self,data,to=None ,room=None ,skip_sid=None ,namespace=None ,\n callback=None ,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.emit('message',data=data,to=to,room=room,skip_sid=skip_sid,\n  namespace=namespace,callback=callback,**kwargs)\n  \n def call(self,event,data=None ,to=None ,sid=None ,namespace=None ,\n timeout=60,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if to is None and sid is None :\n   raise ValueError('Cannot use call() to broadcast.')\n  if not self.async_handlers:\n   raise RuntimeError(\n   'Cannot use call() when async_handlers is False.')\n  callback_event=self.eio.create_event()\n  callback_args=[]\n  \n  def event_callback(*args):\n   callback_args.append(args)\n   callback_event.set()\n   \n  self.emit(event,data=data,room=to or sid,namespace=namespace,\n  callback=event_callback,**kwargs)\n  if not callback_event.wait(timeout=timeout):\n   raise exceptions.TimeoutError()\n  return callback_args[0]if len(callback_args[0])>1\\\n  else callback_args[0][0]if len(callback_args[0])==1\\\n  else None\n  \n def enter_room(self,sid,room,namespace=None ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  self.logger.info('%s is entering room %s [%s]',sid,room,namespace)\n  self.manager.enter_room(sid,namespace,room)\n  \n def leave_room(self,sid,room,namespace=None ):\n  ''\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  self.logger.info('%s is leaving room %s [%s]',sid,room,namespace)\n  self.manager.leave_room(sid,namespace,room)\n  \n def close_room(self,room,namespace=None ):\n  ''\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  self.logger.info('room %s is closing [%s]',room,namespace)\n  self.manager.close_room(room,namespace)\n  \n def rooms(self,sid,namespace=None ):\n  ''\n\n\n\n\n  \n  namespace=namespace or '/'\n  return self.manager.get_rooms(sid,namespace)\n  \n def get_session(self,sid,namespace=None ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  eio_sid=self.manager.eio_sid_from_sid(sid,namespace)\n  eio_session=self.eio.get_session(eio_sid)\n  return eio_session.setdefault(namespace,{})\n  \n def save_session(self,sid,session,namespace=None ):\n  ''\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  eio_sid=self.manager.eio_sid_from_sid(sid,namespace)\n  eio_session=self.eio.get_session(eio_sid)\n  eio_session[namespace]=session\n  \n def session(self,sid,namespace=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  class _session_context_manager(object):\n   def __init__(self,server,sid,namespace):\n    self.server=server\n    self.sid=sid\n    self.namespace=namespace\n    self.session=None\n    \n   def __enter__(self):\n    self.session=self.server.get_session(sid,\n    namespace=namespace)\n    return self.session\n    \n   def __exit__(self,*args):\n    self.server.save_session(sid,self.session,\n    namespace=namespace)\n    \n  return _session_context_manager(self,sid,namespace)\n  \n def disconnect(self,sid,namespace=None ,ignore_queue=False ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  namespace=namespace or '/'\n  if ignore_queue:\n   delete_it=self.manager.is_connected(sid,namespace)\n  else :\n   delete_it=self.manager.can_disconnect(sid,namespace)\n  if delete_it:\n   self.logger.info('Disconnecting %s [%s]',sid,namespace)\n   eio_sid=self.manager.pre_disconnect(sid,namespace=namespace)\n   self._send_packet(eio_sid,self.packet_class(\n   packet.DISCONNECT,namespace=namespace))\n   self._trigger_event('disconnect',namespace,sid)\n   self.manager.disconnect(sid,namespace=namespace)\n   \n def transport(self,sid):\n  ''\n\n\n\n\n\n  \n  return self.eio.transport(sid)\n  \n def get_environ(self,sid,namespace=None ):\n  ''\n\n\n\n\n  \n  eio_sid=self.manager.eio_sid_from_sid(sid,namespace or '/')\n  return self.environ.get(eio_sid)\n  \n def handle_request(self,environ,start_response):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  return self.eio.handle_request(environ,start_response)\n  \n def start_background_task(self,target,*args,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return self.eio.start_background_task(target,*args,**kwargs)\n  \n def sleep(self,seconds=0):\n  ''\n\n\n\n\n\n  \n  return self.eio.sleep(seconds)\n  \n def _emit_internal(self,eio_sid,event,data,namespace=None ,id=None ):\n  ''\n  \n  \n  if isinstance(data,tuple):\n   data=list(data)\n  elif data is not None :\n   data=[data]\n  else :\n   data=[]\n  self._send_packet(eio_sid,self.packet_class(\n  packet.EVENT,namespace=namespace,data=[event]+data,id=id))\n  \n def _send_packet(self,eio_sid,pkt):\n  ''\n  encoded_packet=pkt.encode()\n  if isinstance(encoded_packet,list):\n   for ep in encoded_packet:\n    self.eio.send(eio_sid,ep)\n  else :\n   self.eio.send(eio_sid,encoded_packet)\n   \n def _handle_connect(self,eio_sid,namespace,data):\n  ''\n  namespace=namespace or '/'\n  sid=None\n  if namespace in self.handlers or namespace in self.namespace_handlers:\n   sid=self.manager.connect(eio_sid,namespace)\n  if sid is None :\n   self._send_packet(eio_sid,self.packet_class(\n   packet.CONNECT_ERROR,data='Unable to connect',\n   namespace=namespace))\n   return\n   \n  if self.always_connect:\n   self._send_packet(eio_sid,self.packet_class(\n   packet.CONNECT,{'sid':sid},namespace=namespace))\n  fail_reason=exceptions.ConnectionRefusedError().error_args\n  try :\n   if data:\n    success=self._trigger_event(\n    'connect',namespace,sid,self.environ[eio_sid],data)\n   else :\n    try :\n     success=self._trigger_event(\n     'connect',namespace,sid,self.environ[eio_sid])\n    except TypeError:\n     success=self._trigger_event(\n     'connect',namespace,sid,self.environ[eio_sid],None )\n  except exceptions.ConnectionRefusedError as exc:\n   fail_reason=exc.error_args\n   success=False\n   \n  if success is False :\n   if self.always_connect:\n    self.manager.pre_disconnect(sid,namespace)\n    self._send_packet(eio_sid,self.packet_class(\n    packet.DISCONNECT,data=fail_reason,namespace=namespace))\n   else :\n    self._send_packet(eio_sid,self.packet_class(\n    packet.CONNECT_ERROR,data=fail_reason,\n    namespace=namespace))\n   self.manager.disconnect(sid,namespace)\n  elif not self.always_connect:\n   self._send_packet(eio_sid,self.packet_class(\n   packet.CONNECT,{'sid':sid},namespace=namespace))\n   \n def _handle_disconnect(self,eio_sid,namespace):\n  ''\n  namespace=namespace or '/'\n  sid=self.manager.sid_from_eio_sid(eio_sid,namespace)\n  if not self.manager.is_connected(sid,namespace):\n   return\n  self.manager.pre_disconnect(sid,namespace=namespace)\n  self._trigger_event('disconnect',namespace,sid)\n  self.manager.disconnect(sid,namespace)\n  \n def _handle_event(self,eio_sid,namespace,id,data):\n  ''\n  namespace=namespace or '/'\n  sid=self.manager.sid_from_eio_sid(eio_sid,namespace)\n  self.logger.info('received event \"%s\" from %s [%s]',data[0],sid,\n  namespace)\n  if not self.manager.is_connected(sid,namespace):\n   self.logger.warning('%s is not connected to namespace %s',\n   sid,namespace)\n   return\n  if self.async_handlers:\n   self.start_background_task(self._handle_event_internal,self,sid,\n   eio_sid,data,namespace,id)\n  else :\n   self._handle_event_internal(self,sid,eio_sid,data,namespace,\n   id)\n   \n def _handle_event_internal(self,server,sid,eio_sid,data,namespace,\n id):\n  r=server._trigger_event(data[0],namespace,sid,*data[1:])\n  if r !=self.not_handled and id is not None :\n  \n  \n   if r is None :\n    data=[]\n   elif isinstance(r,tuple):\n    data=list(r)\n   else :\n    data=[r]\n   server._send_packet(eio_sid,self.packet_class(\n   packet.ACK,namespace=namespace,id=id,data=data))\n   \n def _handle_ack(self,eio_sid,namespace,id,data):\n  ''\n  namespace=namespace or '/'\n  sid=self.manager.sid_from_eio_sid(eio_sid,namespace)\n  self.logger.info('received ack from %s [%s]',sid,namespace)\n  self.manager.trigger_callback(sid,id,data)\n  \n def _trigger_event(self,event,namespace,*args):\n  ''\n  \n  if namespace in self.handlers:\n   if event in self.handlers[namespace]:\n    return self.handlers[namespace][event](*args)\n   elif event not in self.reserved_events and\\\n   '*'in self.handlers[namespace]:\n    return self.handlers[namespace]['*'](event,*args)\n   else :\n    return self.not_handled\n    \n    \n  elif namespace in self.namespace_handlers:\n   return self.namespace_handlers[namespace].trigger_event(\n   event,*args)\n   \n def _handle_eio_connect(self,eio_sid,environ):\n  ''\n  if not self.manager_initialized:\n   self.manager_initialized=True\n   self.manager.initialize()\n  self.environ[eio_sid]=environ\n  \n def _handle_eio_message(self,eio_sid,data):\n  ''\n  if eio_sid in self._binary_packet:\n   pkt=self._binary_packet[eio_sid]\n   if pkt.add_attachment(data):\n    del self._binary_packet[eio_sid]\n    if pkt.packet_type ==packet.BINARY_EVENT:\n     self._handle_event(eio_sid,pkt.namespace,pkt.id,\n     pkt.data)\n    else :\n     self._handle_ack(eio_sid,pkt.namespace,pkt.id,pkt.data)\n  else :\n   pkt=self.packet_class(encoded_packet=data)\n   if pkt.packet_type ==packet.CONNECT:\n    self._handle_connect(eio_sid,pkt.namespace,pkt.data)\n   elif pkt.packet_type ==packet.DISCONNECT:\n    self._handle_disconnect(eio_sid,pkt.namespace)\n   elif pkt.packet_type ==packet.EVENT:\n    self._handle_event(eio_sid,pkt.namespace,pkt.id,pkt.data)\n   elif pkt.packet_type ==packet.ACK:\n    self._handle_ack(eio_sid,pkt.namespace,pkt.id,pkt.data)\n   elif pkt.packet_type ==packet.BINARY_EVENT or\\\n   pkt.packet_type ==packet.BINARY_ACK:\n    self._binary_packet[eio_sid]=pkt\n   elif pkt.packet_type ==packet.CONNECT_ERROR:\n    raise ValueError('Unexpected CONNECT_ERROR packet.')\n   else :\n    raise ValueError('Unknown packet type.')\n    \n def _handle_eio_disconnect(self,eio_sid):\n  ''\n  for n in list(self.manager.get_namespaces()).copy():\n   self._handle_disconnect(eio_sid,n)\n  if eio_sid in self.environ:\n   del self.environ[eio_sid]\n   \n def _engineio_server_class(self):\n  return engineio.Server\n", ["engineio", "logging", "socketio"]], "socketio.tornado": [".py", "import sys\nif sys.version_info >=(3,5):\n try :\n  from engineio.async_drivers.tornado import get_tornado_handler as\\\n  get_engineio_handler\n except ImportError:\n  get_engineio_handler=None\n  \n  \ndef get_tornado_handler(socketio_server):\n return get_engineio_handler(socketio_server.eio)\n", ["engineio.async_drivers.tornado", "sys"]], "socketio.zmq_manager": [".py", "import pickle\nimport re\n\ntry :\n import eventlet.green.zmq as zmq\nexcept ImportError:\n zmq=None\n \nfrom .pubsub_manager import PubSubManager\n\n\nclass ZmqManager(PubSubManager):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name='zmq'\n \n def __init__(self,url='zmq+tcp://localhost:5555+5556',\n channel='socketio',\n write_only=False ,\n logger=None ):\n  if zmq is None :\n   raise RuntimeError('zmq package is not installed '\n   '(Run \"pip install pyzmq\" in your '\n   'virtualenv).')\n   \n  r=re.compile(r':\\d+\\+\\d+$')\n  if not (url.startswith('zmq+tcp://')and r.search(url)):\n   raise RuntimeError('unexpected connection string: '+url)\n   \n  url=url.replace('zmq+','')\n  (sink_url,sub_port)=url.split('+')\n  sink_port=sink_url.split(':')[-1]\n  sub_url=sink_url.replace(sink_port,sub_port)\n  \n  sink=zmq.Context().socket(zmq.PUSH)\n  sink.connect(sink_url)\n  \n  sub=zmq.Context().socket(zmq.SUB)\n  sub.setsockopt_string(zmq.SUBSCRIBE,u'')\n  sub.connect(sub_url)\n  \n  self.sink=sink\n  self.sub=sub\n  self.channel=channel\n  super(ZmqManager,self).__init__(channel=channel,\n  write_only=write_only,\n  logger=logger)\n  \n def _publish(self,data):\n  pickled_data=pickle.dumps(\n  {\n  'type':'message',\n  'channel':self.channel,\n  'data':data\n  }\n  )\n  return self.sink.send(pickled_data)\n  \n def zmq_listen(self):\n  while True :\n   response=self.sub.recv()\n   if response is not None :\n    yield response\n    \n def _listen(self):\n  for message in self.zmq_listen():\n   if isinstance(message,bytes):\n    try :\n     message=pickle.loads(message)\n    except Exception:\n     pass\n   if isinstance(message,dict)and\\\n   message['type']=='message'and\\\n   message['channel']==self.channel and\\\n   'data'in message:\n    yield message['data']\n  return\n", ["eventlet.green.zmq", "pickle", "re", "socketio.pubsub_manager"]], "socketio": [".py", "import sys\n\nfrom .client import Client\nfrom .base_manager import BaseManager\nfrom .pubsub_manager import PubSubManager\nfrom .kombu_manager import KombuManager\nfrom .redis_manager import RedisManager\nfrom .kafka_manager import KafkaManager\nfrom .zmq_manager import ZmqManager\nfrom .server import Server\nfrom .namespace import Namespace,ClientNamespace\nfrom .middleware import WSGIApp,Middleware\nfrom .tornado import get_tornado_handler\nif sys.version_info >=(3,5):\n from .asyncio_client import AsyncClient\n from .asyncio_server import AsyncServer\n from .asyncio_manager import AsyncManager\n from .asyncio_namespace import AsyncNamespace,AsyncClientNamespace\n from .asyncio_redis_manager import AsyncRedisManager\n from .asyncio_aiopika_manager import AsyncAioPikaManager\n from .asgi import ASGIApp\nelse :\n AsyncClient=None\n AsyncServer=None\n AsyncManager=None\n AsyncNamespace=None\n AsyncRedisManager=None\n AsyncAioPikaManager=None\n \n__all__=['Client','Server','BaseManager','PubSubManager',\n'KombuManager','RedisManager','ZmqManager','KafkaManager',\n'Namespace','ClientNamespace','WSGIApp','Middleware']\nif AsyncServer is not None :\n __all__ +=['AsyncClient','AsyncServer','AsyncNamespace',\n 'AsyncClientNamespace','AsyncManager','AsyncRedisManager',\n 'ASGIApp','get_tornado_handler','AsyncAioPikaManager']\n", ["socketio.asgi", "socketio.asyncio_aiopika_manager", "socketio.asyncio_client", "socketio.asyncio_manager", "socketio.asyncio_namespace", "socketio.asyncio_redis_manager", "socketio.asyncio_server", "socketio.base_manager", "socketio.client", "socketio.kafka_manager", "socketio.kombu_manager", "socketio.middleware", "socketio.namespace", "socketio.pubsub_manager", "socketio.redis_manager", "socketio.server", "socketio.tornado", "socketio.zmq_manager", "sys"], 1], "socketio.tests.performance_test": [".py", "import asyncio\nimport logging\nimport os\nimport random\nimport string\nimport threading\nimport time\n\nfrom socketio.server import SocketServer\nfrom socketio.client import SocketClient\n\n\nclass PerformanceTest:\n\n def __init__(self):\n  self.terminate=False\n  self._server=None\n  self._socket_client=None\n  self.received_messages=0\n  self.sended_messages=0\n  self.conditions=[]\n  self.cps={\"miatel\":7,\"comlink\":7,\"spacetel\":7}\n  operators={\"miatel\":14,\"comlink\":10,\"spacetel\":4}\n  self.resources={}\n  self.call_delays={}\n  self.last_call_at={}\n  self.call_locks={}\n  for key,value in self.cps.items():\n   self.call_delays[key]=1.0 /float(value)\n   self.last_call_at[key]=time.time()\n   self.call_locks[key]=asyncio.Lock()\n  i=0\n  k=0\n  while i <15:\n   i +=1\n   for operator,cnt in operators.items():\n    j=0\n    while j <cnt:\n     j +=1\n     k +=1\n     self.resources[k]={\"conditions\":[],\"is_busy\":0,\"cs\":threading.Lock(),\"operator\":operator}\n  self.timings=[]\n  \n @asyncio.coroutine\n def run(self):\n  while not self.terminate:\n   yield from asyncio.sleep(1)\n   \n def create_server(self):\n  loop=asyncio.get_event_loop()\n  path=os.path.dirname(os.path.abspath(__file__))\n  self._server=SocketServer({\"test\":self.test_server,\"test_waiting\":self.test_waiting},path+'/configs/socket_server.ini')\n  loop.run_until_complete(self.run())\n  \n def create_client(self):\n  loop=asyncio.get_event_loop()\n  self._socket_client=SocketClient([\"127.0.0.1\",\"54445\"],\n  {\"test\":self.test_client,\"action1\":self.action1})\n  loop.create_task(self._socket_client.connector())\n  loop.run_until_complete(self.run())\n  \n def take_resource(self):\n  timed_out=False\n  message_showed=False\n  time_out=300\n  while not timed_out:\n   for resource_id,resource in self.resources.items():\n    resource[\"cs\"].acquire()\n    if not resource[\"is_busy\"]:\n     resource[\"is_busy\"]=1\n     resource[\"cs\"].release()\n     return resource_id,resource[\"operator\"]\n    resource[\"cs\"].release()\n   if not message_showed:\n    print(\"all resources as busy, wait\")\n    message_showed=True\n   condition=threading.Condition()\n   with condition:\n    self.conditions.append(condition)\n    timed_out=not condition.wait(time_out)\n  raise Exception(\"failed to take resource\")\n  \n def release_resource(self,resource_id):\n  resource=self.resources[resource_id]\n  resource[\"is_busy\"]=0\n  if len(self.conditions)>0:\n   condition=self.conditions.pop(0)\n   with condition:\n    condition.notify()\n  resource[\"conditions\"]=[]\n  \n def sending_as_client(self,message,count=1,length=16,timeout=0.1,with_wait=False ):\n  if self._socket_client is not None :\n   counter=0\n   while counter <count:\n    counter +=1\n    self.sended_messages +=1\n    if with_wait:\n     print(\"start waiting for response\")\n     time1=time.time()\n     self._socket_client.append_message({\"action\":\"test_waiting\",\"test\":message,\"time\":time.time()},True )\n     print(\"waiting response time: %f\"%(time.time()-time1))\n     time.sleep(timeout)\n    else :\n     resource_id,operator=self.take_resource()\n     self._socket_client.append_message({\"action\":\"test\",\"test\":message,\"time\":time.time(),\n     \"resource_id\":resource_id,\"operator\":operator})\n     time.sleep(timeout)\n  else :\n   print(\"ERROR! no client exists!\")\n   \n def server_worker(self,message):\n  repeat_cnt=random.choice([0,1,2,3])\n  i=0\n  while i <repeat_cnt:\n   i +=1\n   sleep_time=random.choice([1,2,0,1,1,4,1,3,2,5,10])\n   time.sleep(sleep_time)\n   self._server.broadcast_message({\"action\":\"action1\",\"test\":message[\"test\"]})\n  sleep_time=random.choice([1,2,0,1,1,4,1,3,2,5])\n  time.sleep(sleep_time)\n  self._server.broadcast_message(message)\n  \n @asyncio.coroutine\n def test_server(self,message):\n  print(\"receiving time: %f\"%(time.time()-message[\"time\"]))\n  self.timings.append(time.time()-message[\"time\"])\n  self.received_messages +=1\n  with (yield from self.call_locks[message[\"operator\"]]):\n   current_delay=time.time()-self.last_call_at[message[\"operator\"]]\n   if current_delay <self.call_delays[message[\"operator\"]]:\n    yield from asyncio.sleep(self.call_delays[message[\"operator\"]]-current_delay)\n   self.last_call_at[message[\"operator\"]]=time.time()\n  worker_thread=threading.Thread(target=self.server_worker,\n  args=(message,))\n  worker_thread.daemon=True\n  worker_thread.start()\n  \n @asyncio.coroutine\n def test_waiting(self,message):\n  print(\"receive waiting time: %f\"%(time.time()-message[\"time\"]))\n  self.timings.append(time.time()-message[\"time\"])\n  self.received_messages +=1\n  time.sleep(5)\n  return {\"action\":\"test_waiting\",\"response\":\"success\"}\n  \n @asyncio.coroutine\n def test_client(self,message):\n  self.timings.append(time.time()-message[\"time\"])\n  self.received_messages +=1\n  self.release_resource(message[\"resource_id\"])\n  \n @asyncio.coroutine\n def action1(self,message):\n  action_tread=threading.Thread(target=self._action_worker)\n  action_tread.daemon=True\n  action_tread.start()\n  \n def _action_worker(self):\n  sleep_time=random.choice([1,2,0,1,1,4,12,8,3,5])\n  time.sleep(sleep_time)\n", ["asyncio", "logging", "os", "random", "socketio.client", "socketio.server", "string", "threading", "time"]], "socketio.tests": [".py", "", [], 1]}
__BRYTHON__.update_VFS(scripts)
